<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="keywords" content="Hexo Theme Redefine">
    
    <meta name="author" content="HangYF">
    <!-- preconnect -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>

    
    <!--- Seo Part-->
    
    <link rel="canonical" href="https://example.com/2025/02/17/机器学习概念总结/"/>
    <meta name="robots" content="index,follow">
    <meta name="googlebot" content="index,follow">
    <meta name="revisit-after" content="1 days">
    
    
    
        
        <meta name="description" content="Redefine.">
<meta property="og:type" content="article">
<meta property="og:title" content="机器学习概念总结">
<meta property="og:url" content="https://example.com/2025/02/17/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%A6%82%E5%BF%B5%E6%80%BB%E7%BB%93/index.html">
<meta property="og:site_name" content="HanG&#39;s Blog">
<meta property="og:description" content="Redefine.">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://example.com/images/redefine-og.webp">
<meta property="article:published_time" content="2025-02-17T06:25:54.000Z">
<meta property="article:modified_time" content="2025-02-17T06:27:33.057Z">
<meta property="article:author" content="HanG">
<meta property="article:tag" content="课程总结">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://example.com/images/redefine-og.webp">
    
    
    <!--- Icon Part-->
    <link rel="icon" type="image/png" href="https://bluewhale-33.oss-cn-nanjing.aliyuncs.com/undefinedalien.svg" sizes="192x192">
    <link rel="apple-touch-icon" sizes="180x180" href="https://bluewhale-33.oss-cn-nanjing.aliyuncs.com/undefinedalien.svg">
    <meta name="theme-color" content="#f9a633">
    <link rel="shortcut icon" href="https://bluewhale-33.oss-cn-nanjing.aliyuncs.com/undefinedalien.svg">
    <!--- Page Info-->
    
    <title>
        
            机器学习概念总结 | HanG&#39;s Space
        
    </title>

    
<link rel="stylesheet" href="/fonts/Chillax/chillax.css">


    <!--- Inject Part-->
    

    
<link rel="stylesheet" href="/css/style.css">


    
        
<link rel="stylesheet" href="/css/build/tailwind.css">

    

    
<link rel="stylesheet" href="/fonts/GeistMono/geist-mono.css">

    
<link rel="stylesheet" href="/fonts/Geist/geist.css">

    <!--- Font Part-->
    
        <link href="https://fonts.googleapis.com/css2?family=Lobster&display=swap" rel="stylesheet">
    
    
    
    
    
        <link href="https://fonts.googleapis.com/css2?family=Lobster&display=swap" rel="stylesheet">
    
    

    <script id="hexo-configurations">
    window.config = {"hostname":"example.com","root":"/","language":"en","path":"search.xml"};
    window.theme = {"articles":{"style":{"font_size":"16px","line_height":1.5,"image_border_radius":"14px","image_alignment":"center","image_caption":false,"link_icon":true,"delete_mask":false,"title_alignment":"left","headings_top_spacing":{"h1":"3.2rem","h2":"2.4rem","h3":"1.9rem","h4":"1.6rem","h5":"1.4rem","h6":"1.3rem"}},"word_count":{"enable":true,"count":true,"min2read":true},"author_label":{"enable":true,"auto":false,"list":[]},"code_block":{"copy":true,"style":"mac","highlight_theme":{"light":"github","dark":"vs2015"},"font":{"enable":false,"family":null,"url":null}},"toc":{"enable":true,"max_depth":3,"number":false,"expand":true,"init_open":true},"copyright":{"enable":true,"default":"cc_by_nc_sa"},"lazyload":true,"pangu_js":false,"recommendation":{"enable":false,"title":"推荐阅读","limit":3,"mobile_limit":2,"placeholder":"/images/wallhaven-wqery6-light.webp","skip_dirs":[]}},"colors":{"primary":"#f9a633","secondary":null,"default_mode":"light"},"global":{"fonts":{"chinese":{"enable":false,"family":null,"url":null},"english":{"enable":false,"family":null,"url":null},"title":{"enable":true,"family":"Lobster","url":"https://fonts.googleapis.com/css2?family=Lobster&display=swap"}},"content_max_width":"1000px","sidebar_width":"210px","hover":{"shadow":true,"scale":false},"scroll_progress":{"bar":false,"percentage":true},"website_counter":{"url":"https://cn.vercount.one/js","enable":false,"site_pv":true,"site_uv":true,"post_pv":true},"single_page":true,"preloader":{"enable":false,"custom_message":null},"open_graph":{"enable":true,"image":"/images/redefine-og.webp","description":"Redefine."},"google_analytics":{"enable":false,"id":null}},"home_banner":{"enable":true,"style":"fixed","image":{"light":"/images/wallhaven-wqery6-light.webp# light mode","dark":"https://bluewhale-33.oss-cn-nanjing.aliyuncs.com/undefined126275647_p0.webp"},"title":"code for the future","subtitle":{"text":["Loading..."],"hitokoto":{"enable":true,"show_author":false,"api":"https://v1.hitokoto.cn"},"typing_speed":100,"backing_speed":80,"starting_delay":500,"backing_delay":1500,"loop":false,"smart_backspace":true},"text_color":{"light":"#ffffff","dark":"#e8e9e9"},"text_style":{"title_size":"2.8rem","subtitle_size":"1.5rem","line_height":1.2},"custom_font":{"enable":true,"family":"Lobster","url":"https://fonts.googleapis.com/css2?family=Lobster&display=swap"},"social_links":{"enable":false,"style":"default","links":{"github":null,"instagram":null,"zhihu":null,"twitter":null,"email":null},"qrs":{"weixin":null}}},"plugins":{"feed":{"enable":false},"aplayer":{"enable":false,"type":"fixed","audios":[{"name":null,"artist":null,"url":null,"cover":null,"lrc":null}]},"mermaid":{"enable":false,"version":"11.4.1"}},"version":"2.8.2","navbar":{"auto_hide":false,"color":{"left":"#fff","right":"#fff","transparency":35},"width":{"home":"1200px","pages":"1000px"},"links":{"Home":{"path":"/","icon":"fa-regular fa-house"},"归档":{"path":"/archives","icon":"fa-regular fa-archive"},"标签":{"path":"/tags/","icon":"fa-solid fa-tags"},"分类":{"path":"/categories/","icon":"fa-solid fa-folder"}},"search":{"enable":true,"preload":true}},"page_templates":{"friends_column":2,"tags_style":"blur"},"home":{"sidebar":{"enable":true,"position":"left","first_item":"menu","announcement":null,"show_on_mobile":true,"links":null},"article_date_format":"auto","excerpt_length":200,"categories":{"enable":true,"limit":3},"tags":{"enable":true,"limit":3}},"footerStart":"2025/1/25 11:45:14"};
    window.lang_ago = {"second":"%s seconds ago","minute":"%s minutes ago","hour":"%s hours ago","day":"%s days ago","week":"%s weeks ago","month":"%s months ago","year":"%s years ago"};
    window.data = {"masonry":false};
  </script>
    
    <!--- Fontawesome Part-->
    
<link rel="stylesheet" href="/fontawesome/fontawesome.min.css">

    
<link rel="stylesheet" href="/fontawesome/brands.min.css">

    
<link rel="stylesheet" href="/fontawesome/solid.min.css">

    
<link rel="stylesheet" href="/fontawesome/regular.min.css">

    
    
    
    
<meta name="generator" content="Hexo 7.3.0"></head>



<body>
	<div class="progress-bar-container">
	

	
	<span class="pjax-progress-bar"></span>
	<!--        <span class="swup-progress-icon">-->
	<!--            <i class="fa-solid fa-circle-notch fa-spin"></i>-->
	<!--        </span>-->
	
</div>

<main class="page-container" id="swup">

	

	<div class="main-content-container flex flex-col justify-between min-h-dvh">
		<div class="main-content-header">
			<header class="navbar-container px-6 md:px-12">
    <div class="navbar-content transition-navbar ">
        <div class="left">
            
            <a class="logo-title" href="/">
                
                HanG&#39;s Space
                
            </a>
        </div>

        <div class="right">
            <!-- PC -->
            <div class="desktop">
                <ul class="navbar-list">
                    
                        
                            

                            <li class="navbar-item">
                                <!-- Menu -->
                                <a class=""
                                   href="/"
                                        >
                                    <i class="fa-regular fa-house fa-fw"></i>
                                    HOME
                                    
                                </a>

                                <!-- Submenu -->
                                
                            </li>
                    
                        
                            

                            <li class="navbar-item">
                                <!-- Menu -->
                                <a class=""
                                   href="/archives"
                                        >
                                    <i class="fa-regular fa-archive fa-fw"></i>
                                    归档
                                    
                                </a>

                                <!-- Submenu -->
                                
                            </li>
                    
                        
                            

                            <li class="navbar-item">
                                <!-- Menu -->
                                <a class=""
                                   href="/tags/"
                                        >
                                    <i class="fa-solid fa-tags fa-fw"></i>
                                    标签
                                    
                                </a>

                                <!-- Submenu -->
                                
                            </li>
                    
                        
                            

                            <li class="navbar-item">
                                <!-- Menu -->
                                <a class=""
                                   href="/categories/"
                                        >
                                    <i class="fa-solid fa-folder fa-fw"></i>
                                    分类
                                    
                                </a>

                                <!-- Submenu -->
                                
                            </li>
                    
                    
                        <li class="navbar-item search search-popup-trigger">
                            <i class="fa-solid fa-magnifying-glass"></i>
                        </li>
                    
                </ul>
            </div>
            <!-- Mobile -->
            <div class="mobile">
                
                    <div class="icon-item search search-popup-trigger"><i class="fa-solid fa-magnifying-glass"></i>
                    </div>
                
                <div class="icon-item navbar-bar">
                    <div class="navbar-bar-middle"></div>
                </div>
            </div>
        </div>
    </div>

    <!-- Mobile sheet -->
    <div class="navbar-drawer h-dvh w-full absolute top-0 left-0 bg-background-color flex flex-col justify-between">
        <ul class="drawer-navbar-list flex flex-col px-4 justify-center items-start">
            
                
                    

                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full "
                           href="/"
                        >
                            <span>
                                HOME
                            </span>
                            
                                <i class="fa-regular fa-house fa-sm fa-fw"></i>
                            
                        </a>
                        

                        
                    </li>
            
                
                    

                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full "
                           href="/archives"
                        >
                            <span>
                                归档
                            </span>
                            
                                <i class="fa-regular fa-archive fa-sm fa-fw"></i>
                            
                        </a>
                        

                        
                    </li>
            
                
                    

                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full "
                           href="/tags/"
                        >
                            <span>
                                标签
                            </span>
                            
                                <i class="fa-solid fa-tags fa-sm fa-fw"></i>
                            
                        </a>
                        

                        
                    </li>
            
                
                    

                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full "
                           href="/categories/"
                        >
                            <span>
                                分类
                            </span>
                            
                                <i class="fa-solid fa-folder fa-sm fa-fw"></i>
                            
                        </a>
                        

                        
                    </li>
            

            
            
        </ul>

        <div class="statistics flex justify-around my-2.5">
    <a class="item tag-count-item flex flex-col justify-center items-center w-20" href="/tags">
        <div class="number text-2xl sm:text-xl text-second-text-color font-semibold">3</div>
        <div class="label text-third-text-color text-sm">Tags</div>
    </a>
    <a class="item tag-count-item flex flex-col justify-center items-center w-20" href="/categories">
        <div class="number text-2xl sm:text-xl text-second-text-color font-semibold">7</div>
        <div class="label text-third-text-color text-sm">Categories</div>
    </a>
    <a class="item tag-count-item flex flex-col justify-center items-center w-20" href="/archives">
        <div class="number text-2xl sm:text-xl text-second-text-color font-semibold">7</div>
        <div class="label text-third-text-color text-sm">Posts</div>
    </a>
</div>
    </div>

    <div class="window-mask"></div>

</header>


		</div>

		<div class="main-content-body transition-fade-up">
			

			<div class="main-content">
				<div class="post-page-container flex relative justify-between box-border w-full h-full">
	<div class="article-content-container">

		<div class="article-title relative w-full">
			
			<div class="w-full flex items-center pt-6 justify-start">
				<h1 class="article-title-regular text-second-text-color tracking-tight text-4xl md:text-6xl font-semibold px-2 sm:px-6 md:px-8 py-3">机器学习概念总结</h1>
			</div>
			
		</div>

		
		<div class="article-header flex flex-row gap-2 items-center px-2 sm:px-6 md:px-8">
			<div class="avatar w-[46px] h-[46px] flex-shrink-0 rounded-medium border border-border-color p-[1px]">
				<img src="https://i.scdn.co/image/ab67616d0000b273b55bd8b2452c00eabd91474a">
			</div>
			<div class="info flex flex-col justify-between">
				<div class="author flex items-center">
					<span class="name text-default-text-color text-lg font-semibold">HangYF</span>
					
					<span class="author-label ml-1.5 text-xs px-2 py-0.5 rounded-small text-third-text-color border border-shadow-color-1">Lv1</span>
					
				</div>
				<div class="meta-info">
					<div class="article-meta-info">
    <span class="article-date article-meta-item">
        <i class="fa-regular fa-pen-fancy"></i>&nbsp;
        <span class="desktop">2025-02-17 14:25:54</span>
        <span class="mobile">2025-02-17 14:25:54</span>
        <span class="hover-info">Created</span>
    </span>
    
        <span class="article-date article-meta-item">
            <i class="fa-regular fa-wrench"></i>&nbsp;
            <span class="desktop">2025-02-17 14:27:33</span>
            <span class="mobile">2025-02-17 14:27:33</span>
            <span class="hover-info">Updated</span>
        </span>
    

    
        <span class="article-categories article-meta-item">
            <i class="fa-regular fa-folders"></i>&nbsp;
            <ul>
                
                
                    
                        
                        <li>
                            <a href="/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/">机器学习</a>&nbsp;
                        </li>
                    
                    
                
            </ul>
        </span>
    
    
        <span class="article-tags article-meta-item">
            <i class="fa-regular fa-tags"></i>&nbsp;
            <ul>
                
                    <li>
                        <a href="/tags/%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93/">课程总结</a>&nbsp;
                    </li>
                
            </ul>
        </span>
    

    
    
        <span class="article-wordcount article-meta-item">
            <i class="fa-regular fa-typewriter"></i>&nbsp;<span>12.2k Words</span>
        </span>
    
    
        <span class="article-min2read article-meta-item">
            <i class="fa-regular fa-clock"></i>&nbsp;<span>43 Mins</span>
        </span>
    
    
</div>

				</div>
			</div>
		</div>
		

		


		<div class="article-content markdown-body px-2 sm:px-6 md:px-8 pb-8">
			<pre><code>写在前面：课程是完全按照西瓜书来讲的，相当于是西瓜书的读后感
</code></pre>
<h1 id="机器学习"><a href="#机器学习" class="headerlink" title="机器学习"></a>机器学习</h1><p><strong>寻找上帝函数的过程</strong></p>
<h2 id="绪论"><a href="#绪论" class="headerlink" title="绪论"></a>绪论</h2><p>机器学习<strong>是一个建模的过程 通过已知的数据总结规律用于将来的预测</strong>。 这个模型接受预测变量（自变量，属性变量），输出的是响应变量（因变量）。一般而言，模型接收多个预测变量。</p>
<p>我们可以假设，现实中的预测变量$X&#x3D;(x_1,x_2,..x_p)$和响应变量$Y$的关系是：</p>
<p>$$ Y&#x3D;f(X)  + \epsilon$$</p>
<p>其中 $\epsilon$ 表示<strong>随机误差项</strong>,与$X$独立，且均值为0。</p>
<p>而机器学习的任务，就是估计这个$f(x)$函数。在两种情况下会估计f ：<strong>预测</strong>和<strong>推断</strong></p>
<h3 id="预测"><a href="#预测" class="headerlink" title="预测"></a>预测</h3><p>多数情境下，输入是已知的，我们需要预测输出。由于随机误差项的均值为0，所以可以通过下式进行预测：</p>
<p>$$\hat{Y}&#x3D;\hat{f}(X)$$</p>
<p>其中$\hat{f}(X)$是对函数的估计，我们不在乎他的形式，可以视作黑箱，$\hat{Y}$的精确性依赖于两个量，<strong>可约误差</strong>和<strong>不可约误差</strong>。可约误差来自于建模的精确性问题，换句话说，一个更好的模型<strong>会提高对函数估计的精确性</strong>，是可以人为提高的。如果已经完全复现了原来的函数（实际上不可能），此时对于响应变量的估计来源于下式：</p>
<p>$$\hat{Y}&#x3D;f(x)$$</p>
<p>可见这个式子没有考虑随机误差项，但Y也是一个关于$\epsilon$的函数。可是，实际上<strong>永远也无法考虑$\epsilon$的影响</strong>，因为$\epsilon$和X是独立的，无法用X来预测$\epsilon$。这部分误差就是不可约误差。无论我们对$f(x)$的估计有多准确，都是无法减少$\epsilon$带来的误差的。</p>
<p>$\epsilon$包含了<strong>对Y有影响</strong>但是<strong>无法观测</strong>的变量信息。（假设所有可观测且有影响的变量都被观测的情况下）如病人的服药效果和他的心情，天气，空气湿度都有影响，<strong>但是这些变量无法加入响应变量</strong>中。现实世界的情况很复杂。所以，<strong>不可约误差提供了一个建模精度的上限</strong>。</p>
<h3 id="推断"><a href="#推断" class="headerlink" title="推断"></a>推断</h3><p>推断对建模提出了更高的要求。我们想弄明白X和Y的关系到底是怎样的。可能的问题有：</p>
<ul>
<li><strong>哪些预测变量和响应变量有关</strong>？通常情况下，只有一部分预测变量和响应变量有关。</li>
<li><strong>响应变量和每个预测变量之间的关系是怎样的</strong>？有些预测变量和响应变量是正相关的，有些是负相关的</li>
<li><strong>响应变量和每个预测变量的关系可以用线性方程描述吗</strong>？ 大多数估计f的方式是使用<strong>线性方程</strong>，但是更一般的情况下，需要更复杂的模型。</li>
</ul>
<p>显然，此时的函数不能是一个黑盒的形式了，我们需要他的具体形式。</p>
<h3 id="如何估计f"><a href="#如何估计f" class="headerlink" title="如何估计f"></a>如何估计f</h3><h4 id="参数方法"><a href="#参数方法" class="headerlink" title="参数方法"></a>参数方法</h4><p>这是一种基于模型估计的两阶段方法。</p>
<ol>
<li>假设函数f具有一定的形式，如假设f是一个线性模型：<br>$$f(X) &#x3D; \beta_0+\beta_1X_1+\beta_2X_2 …$$<br>此时问题就被简化了，只需要去估计参数$\beta$而不是一个p维函数。</li>
<li>一旦模型被选中，就要使用训练数据来进行<strong>拟合</strong>或者<strong>训练</strong>模型。也就是估计各个参数的值，拟合常用的方法是<strong>普通最小二乘法</strong>。</li>
<li>参数法的缺陷在于<strong>很难选择一个与原函数相近的模型</strong>，如果模型和真实的f相差太大，会导致估计出的f效果很差。解决此类模型的方式是选用一个<strong>更加光滑的模型进行拟合f</strong>，一般来说，拟合光滑度更强的模型需要更多的参数估计。但是拟合复杂的模型会导致<strong>过拟合</strong>的现象出现，也就是将<strong>噪声</strong>和<strong>误差</strong>也拟合了进去。</li>
</ol>
<h4 id="非参数方法"><a href="#非参数方法" class="headerlink" title="非参数方法"></a>非参数方法</h4><p>不需要对模型有事先的假设。</p>
<p><strong>追求尽可能接近数据点的估计</strong>，估计函数在<strong>去粗和光滑处理后尽可能与更多数据点接近</strong>。不局限f的具体形式，可以在更大范围内选择适合f形状的估计。</p>
<p>弱点在于：问题复杂，需要更多观测点来实现更精确的估计。</p>
<h3 id="预测精度和解释性的权衡"><a href="#预测精度和解释性的权衡" class="headerlink" title="预测精度和解释性的权衡"></a>预测精度和解释性的权衡</h3><p>在众多估计方法中，有一些是<strong>欠光滑的</strong>，或者说形式上受限定的。这种情况下只能产生一个相对较窄的函数范围来估计f。如线性模型，他只能产生一个线性函数，是相对欠光滑的。但是<strong>薄板样条</strong>是光滑度较高的。</p>
<p><em>为什么使用一个受限的方式，而不是一个光滑模型来建模？</em></p>
<ol>
<li>有时候欠光滑模型就够用了，可能原函数就是一个线性函数</li>
<li>欠光滑模型可解释性更高，复杂的估计中，很难解释一个预测变量是怎么影响到响应变量的。</li>
</ol>
<p><strong>当方法的柔性增强时，方法的解释性下降。反之亦然</strong></p>
<h3 id="指导学习和无指导学习"><a href="#指导学习和无指导学习" class="headerlink" title="指导学习和无指导学习"></a>指导学习和无指导学习</h3><p><strong>指导学习</strong>：</p>
<p>对于每一个预测变量的观测值$x_i(i&#x3D;1,2,3,4,5…)$ 都有一个响应变量的观测 y</p>
<p>建模的目标就是通过建立预测变量和响应变量的关系，进行响应变量的预测或者更好的理解两者关系。</p>
<p>线性回归（linear regression），逻辑斯蒂回归，广义可加模型，提升方法(boosting method)，支持向量机都是指导学习。</p>
<p><strong>无指导学习</strong>：</p>
<p><strong>只有预测变量的观测向量$x_i(i&#x3D;1,2,3,4,5…)$ ,但是没有y与之对应。</strong>不可能对其拟合线性模型，因为缺少响应变量的指导。</p>
<p>无指导学习可能出现在：理解<strong>变量之间或者观测之间的关系</strong>。聚类分析就是一种无指导学习，目标是<strong>基于各种可以观测的变量，将观测值归入不同的群</strong>。</p>
<h3 id="归纳偏好-inductive-bias"><a href="#归纳偏好-inductive-bias" class="headerlink" title="归纳偏好 inductive bias"></a>归纳偏好 inductive bias</h3><p>机器学习算法在学习过程中对某种类型假设的偏好，任何一个有效的机器学习算法必然有其偏好。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://bluewhale-33.oss-cn-nanjing.aliyuncs.com/image-20240930143929916.png"
                      alt="image-20240930143929916"
                ></p>
<p>上面的拟合有两种，机器学习算法会选哪一种取决于它的归纳偏好，如果遵循<strong>奥卡姆剃刀原则</strong>：即相同性能下学习的模型复杂性越低越好，那么A明显更好。</p>
<p><strong>机器学习算法的归纳偏好是否与问题所匹配，大多数时候直接决定了算法是否可以取得好的性能。</strong></p>
<p><strong><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://i-blog.csdnimg.cn/blog_migrate/6ca3321f71123e6ae340adee7a70bafb.png"
                      alt="img"
                ></strong></p>
<h3 id="没有免费的午餐-NO-Free-Lunch"><a href="#没有免费的午餐-NO-Free-Lunch" class="headerlink" title="没有免费的午餐 NO Free Lunch"></a>没有免费的午餐 NO Free Lunch</h3><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://bluewhale-33.oss-cn-nanjing.aliyuncs.com/image-20240930144547408.png"
                      alt="image-20240930144547408"
                ></p>
<p>NFL定理：一个算法a如果在某些问题上比另一个算法b好，必存在另一些问题，b比a好</p>
<h2 id="统计学基本概念"><a href="#统计学基本概念" class="headerlink" title="统计学基本概念"></a>统计学基本概念</h2><ul>
<li><p>均值&#x2F;期望  (mean)</p>
</li>
<li><p>方差 (variance)</p>
</li>
<li><p>标准差&#x2F;均方差 (standard deviation)</p>
</li>
<li><p>协方差矩阵 (covariance matrix)</p>
</li>
<li><p>均方根值 &#x2F;有效值 (Root Mean Square)</p>
</li>
<li><p>均方根误差 (Root Mean Square Error)</p>
</li>
</ul>
<h3 id="距离"><a href="#距离" class="headerlink" title="距离"></a>距离</h3><ul>
<li><p>闵可夫斯基距离</p>
<ul>
<li>闵氏距离是<strong>一组距离</strong>的定义</li>
</ul>
</li>
<li><p>两个n维变量 $a(x_{11},x_{12},x_{13},x_{14},…)$ $b(x_{21},x_{22},x_{23}…)$ 的闵氏距离定义为$d &#x3D; \sqrt[p]{\sum_{k&#x3D;1}^{n}{|x_{1k}-x_{2k}|^p}}$ ，当p&#x3D;1时，就是曼哈顿距离，p&#x3D;2时为欧氏距离；$p\rightarrow +\infty$ 时为切比雪夫距离。</p>
<ul>
<li>其中切比雪夫距离就是国际象棋中<strong>王向其他格子移动的最小距离</strong>。二维平面中的定义是：$d&#x3D;max(|x_1-x_2|,|y_1-y_2|)$</li>
<li>闵氏距离的缺点就是将每个分量的量纲，也就是单位平等的看待了；没有考虑每个分量的分布可能是不同的</li>
</ul>
</li>
<li><p>标准化欧氏距离</p>
<ul>
<li>是欧式距离的改进版-将分量事先标准化到均值，方差都相同。</li>
<li>将分量事先处理$X^* &#x3D; \frac{X-m}{s}$ 减去均值，除以标准差</li>
</ul>
</li>
<li><p>马氏距离</p>
<ul>
<li>消除量纲</li>
<li>$d(x_i,x_y) &#x3D; \sqrt[]{(x_i,x_j)^TM(x_i,x_j)}$  M是协方差矩阵</li>
</ul>
</li>
<li><p>余弦距离</p>
</li>
</ul>
<h3 id="凸函数，凹函数"><a href="#凸函数，凹函数" class="headerlink" title="凸函数，凹函数"></a>凸函数，凹函数</h3><h4 id="凸集"><a href="#凸集" class="headerlink" title="凸集"></a>凸集</h4><p>设有D∈Rn，如果对任意的x,y∈D与任意的α∈[0,1]，都有：<br>αx + (1-α) y &#x3D; 0，<br>那么称D为凸集。</p>
<p><strong>凸集的几何意义：</strong>若两个点属于此集合，则这两个点上的任意一点均属于此集合。</p>
<p>凸集的性质：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://i-blog.csdnimg.cn/blog_migrate/16478868b4936d650954e8f213161e94.jpeg#pic_center"
                      alt="在这里插入图片描述"
                ></p>
<h4 id="凸函数"><a href="#凸函数" class="headerlink" title="凸函数"></a>凸函数</h4><p>设D是非空集，f是定义在D上的函数，如果对任意的x1,x2∈D，均有在这<strong>两点之间的点的函数值小于等于这两点的加权函数值之和</strong>，那么称f为D上的凸函数。</p>
<p>即$x^1,x^2$是属于凸集D的两个变量，$a\in (0,1)$ 满足下式：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://bluewhale-33.oss-cn-nanjing.aliyuncs.com/image-20240930160242384.png"
                      alt="image-20240930160242384"
                ></p>
<p>几何意义：凸函数任意两点之间的曲线段总是在弦下方。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://bluewhale-33.oss-cn-nanjing.aliyuncs.com/image-20240930160030940.png"
                      alt="image-20240930160030940"
                ></p>
<h4 id="判断函数的凹凸性"><a href="#判断函数的凹凸性" class="headerlink" title="判断函数的凹凸性"></a>判断函数的凹凸性</h4><p><strong>一元函数： 二阶导数大于等于0，则为凸函数，</strong>有极小值； 凹函数亦然。</p>
<p><strong>多元函数</strong>：使用海森矩阵，根据矩阵的正定性，判断凹凸性。<strong>半正定为凸函数，非半正定则是凹函数。</strong></p>
<h2 id="模型评估和选择"><a href="#模型评估和选择" class="headerlink" title="模型评估和选择"></a>模型评估和选择</h2><p><em>统计学习方法三要素： 方法 &#x3D; 模型 +策略 + 算法</em></p>
<h3 id="模型-假设空间"><a href="#模型-假设空间" class="headerlink" title="模型&amp;假设空间"></a>模型&amp;假设空间</h3><ul>
<li>模型（model）：是所要学习的条件概率分布或决策函数或映射函数</li>
<li>假设空间（hypothesis space）：包含所有可能的条件概率分布或决策函数集合</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://bluewhale-33.oss-cn-nanjing.aliyuncs.com/image-20240930163703781.png"
                      alt="image-20240930163703781"
                ></p>
<p>更加细节的公式：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://bluewhale-33.oss-cn-nanjing.aliyuncs.com/image-20240930163755509.png"
                      alt="image-20240930163755509"
                ></p>
<p>也就是<strong>模型都是通过参数刻画的，而参数取自于n维欧氏空间</strong>，因此也叫做参数空间。</p>
<h3 id="策略"><a href="#策略" class="headerlink" title="策略"></a>策略</h3><ul>
<li><p>策略（strategy）：如何从假设空间中选择最优的假设模型</p>
</li>
<li><p>损失函数（loss function）或者代价函数（cost function）</p>
<ul>
<li>度量模型一次预测的好坏，记为𝐿( 𝑌,𝑓(𝑋) )，Y是实际值，f（x）是预测值</li>
<li>通常为一个非负实值函数</li>
<li>常见的损失函数如<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://bluewhale-33.oss-cn-nanjing.aliyuncs.com/image-20240930164051544.png"
                      alt="image-20240930164051544"
                ></li>
</ul>
</li>
<li><p>风险函数（risk function）或期望损失（expected loss）</p>
<ul>
<li>度量平均意义下模型预测的好坏，记为$R_{exp}(f)$&#x3D;𝐸[𝐿(𝑌,𝑓(𝑋) ) ]</li>
<li>遗憾的是期望损失并不能直接计算 (需要使用大量的样本计算经验风险来<strong>近似得到风险函数</strong>)</li>
</ul>
</li>
<li><p>经验风险（empirical risk）：模型在训练数据集上的平均损失，记为$R_{emp}(f)$</p>
</li>
<li><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://bluewhale-33.oss-cn-nanjing.aliyuncs.com/image-20240930164505944.png"
                      alt="image-20240930164505944"
                ></p>
</li>
<li><p><strong>经验风险</strong>最小化（empirical riskminimization, ERM）：</p>
<ul>
<li>经验风险最小的模型就是最优的模型</li>
<li>即求解最小化的优化问题：哪个模型满足  $min_{f\inℱ}\frac{1}{𝑁}\sum_{i&#x3D;1}^{N}𝐿(y_i,𝑓(𝒙_i))$</li>
<li>有时候会出现过拟合（over-fitting）现象，例如样本量很少的情况下</li>
</ul>
</li>
<li><p><strong>结构风险</strong>最小化（structural riskminimization, SRM）：</p>
<ul>
<li><p>结构风险最小的模型就是最优的模型</p>
</li>
<li><p>增加<strong>衡量模型复杂度</strong>的<strong>正则化项（regularizer）或罚项（penalty term）</strong></p>
</li>
<li><p>即求解最小化的优化问题：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://bluewhale-33.oss-cn-nanjing.aliyuncs.com/image-20240930165121221.png"
                      alt="image-20240930165121221"
                ></p>
</li>
</ul>
</li>
</ul>
<h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><p>学习模型的具体计算方法</p>
<ul>
<li><strong>统计学习问题往往形式化为一个最优化问题</strong>，如果最优化问题有解析解&#x2F;闭式解（closed-form expression），直接求解</li>
<li>如果最优化问题没有有解析解&#x2F;闭式解（closed-form expression）<ul>
<li>梯度下降（gradientdescent）</li>
<li>牛顿法（Newton method）</li>
<li>拟牛顿法（quasi-Newton method）</li>
<li>…</li>
</ul>
</li>
</ul>
<h3 id="泛化误差-vs-经验误差"><a href="#泛化误差-vs-经验误差" class="headerlink" title="泛化误差 vs 经验误差"></a>泛化误差 vs 经验误差</h3><p>泛化误差：在未来样本上的误差，当然越小越好。</p>
<p>经验误差：在训练集上的误差，不是越小越好，否则过拟合。</p>
<h3 id="模型选择"><a href="#模型选择" class="headerlink" title="模型选择"></a>模型选择</h3><ul>
<li><p>如何获得测试结果？评估方法</p>
</li>
<li><p>如何评估性能优劣？性能度量</p>
</li>
<li><p>如何判断实质差别？比较检验</p>
</li>
</ul>
<h3 id="评估方法"><a href="#评估方法" class="headerlink" title="评估方法"></a>评估方法</h3><p><strong>关键：怎么获得测试集？测试集应该与训练集“互斥”</strong></p>
<p>数据分类方法：</p>
<ul>
<li>留出法 ：<strong>将数据集按比例划分为训练集和测试集</strong></li>
</ul>
<p>注意：</p>
<ol>
<li>要保证测试集中数据的分布不变，可采用分层抽样法</li>
<li>多次随机划分确定最后的测试集</li>
<li>测试集比例在1&#x2F;3-1&#x2F;5</li>
</ol>
<ul>
<li><p>k折-交叉验证法：<strong>将数据集分为k折，如10折即10部分。然后将第10折，第9折…分别作为测试集进行测试，共测试10次，取平均值作为最后的测试结果</strong></p>
</li>
<li><p>自助抽样法：<strong>通过有放回抽样抽取样本，数据集共m个样本则抽取m次，根据数学公式计算可得最后没被抽取的样本集合约占1&#x2F;3，这部分作为测试集，抽取到的作为训练集</strong></p>
</li>
</ul>
<p>注意：</p>
<ol>
<li>训练集与原样本集同规模</li>
<li>数据分布有所改变</li>
</ol>
<h4 id="调参和最终模型"><a href="#调参和最终模型" class="headerlink" title="调参和最终模型"></a>调参和最终模型</h4><ul>
<li><p><strong>算法</strong>的参数：一般由人工设定，亦称“超参数”</p>
</li>
<li><p><strong>模型</strong>的参数：一般由学习确定</p>
</li>
</ul>
<p>验证集可以从训练集中抽取一部分得到，当超参数选定后，要将训练集+验证集重新训练得到最终模型</p>
<p>验证集用于帮助选择最佳的<strong>超参数</strong> ：如KNN中的K，网络层数，网络节点数，迭代次数等等</p>
<p>注意：测试集<strong>仅在</strong>最终评价模型使用，不能参与学习过程</p>
<h3 id="性能度量：衡量模型泛化能力的评价标准，反映了任务需求"><a href="#性能度量：衡量模型泛化能力的评价标准，反映了任务需求" class="headerlink" title="性能度量：衡量模型泛化能力的评价标准，反映了任务需求"></a>性能度量：<strong>衡量模型泛化能力的评价标准，反映了任务需求</strong></h3><h4 id="回归任务"><a href="#回归任务" class="headerlink" title="回归任务"></a>回归任务</h4><p>使用均方误差 （误差平方和的均值）</p>
<p>$$E(f;D) &#x3D; \frac{1}{m}\sum^m_{i&#x3D;1}(f(x_i)-y_i)^2$$</p>
<h4 id="分类任务"><a href="#分类任务" class="headerlink" title="分类任务"></a>分类任务</h4><p>错误率、精度、查准率、查全率计算</p>
<p><strong>混淆矩阵</strong></p>
<p>也称误差矩阵，是表示精度评价的一种标准格式，用n行n列的矩阵形式来表示</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://bluewhale-33.oss-cn-nanjing.aliyuncs.com/image-20241004165832953.png"
                      alt="image-20241004165832953"
                ></p>
<p>正例：positive，即最后结果是正向的（比如好瓜）；<br>反例：negative，即最后结果是负向的（比如烂瓜）；<br>TP：True Positive，把正例预测为正例，也就是说，首先预测出来是个正例，其次这是一个真正的正例（比如预测出来是个好瓜，而且是个好瓜）；<br>FP：False Positive，把反例预测为正例，也就是说，首先预测出来是个正例，其次这是个反例（比如预测出来是个好瓜，但是是个烂瓜）；<br>FN：False Negative，把正例预测为反例，也就是说，首先预测出来是个反例，其次这是个正例（比如预测出来是个烂瓜，但是是个好瓜）；<br>TN：True Negative，把反例预测为反例，也就是说，首先预测出来是个反例，其次这是一个真正的反例（比如预测出来是个烂瓜，而且是个烂瓜）</p>
<p><strong>错误率</strong>：分类错误的次数除以总样本数</p>
<p>$$E(f;D) &#x3D; \frac{1}{m}\sum^m_{i&#x3D;1} bool(f(x_t)\neq y_i)$$</p>
<p>$$E(f;D) &#x3D; \frac{FN+FP}{样本总数}$$</p>
<p><strong>精度</strong>：分类正确的次数除以总样本数 也等于 1- 错误率</p>
<p>$$acc(f;D) &#x3D; \frac{1}{m}\sum^m_{i&#x3D;1} bool(f(x_t)&#x3D; y_i)$$</p>
<p>$$acc(f;D) &#x3D; \frac{TP+FN}{样本总数}$$</p>
<p><strong>查准率</strong>：预测出来为正类中真正的正类所占的比例。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://i-blog.csdnimg.cn/blog_migrate/f2974194f9f38599a23d09e8fb5e8f59.png#pic_center"
                      alt="准确率"
                ></p>
<p><strong>查全率</strong>：预测出来正确的正类占所有真实正类的比例。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://i-blog.csdnimg.cn/blog_migrate/830dc5d2c6aaa1c3cee6379b5c8b87a8.png#pic_center"
                      alt="召回率"
                ></p>
<p><strong>查准率（准确率）和查全率（召回率）是一对矛盾的度量</strong>，查准率高则查全率低，反之亦然。我们可以通过将学习器得到的预测结果对样例进行排序，最<strong>前面的是最有可能为正例的样本，越往后越不可能</strong>，<strong>然后依次对这些样本作为正例进行预测</strong>（不断累积计算，如得到第一个样本的预测情况计算一次，得到第二个预测情况则和第一个一同计算，第三个和第二个，第一个一同计算），可以得到当前的查准率，查全率，以查准率为纵轴，查全率为横轴，得到P-R曲线，其中<strong>平衡点</strong>即为：查准率&#x3D;查全率的点，比较这几个点和原点之间的欧氏距离大小，越大越优。（距离越大，查准率，查全率均越大）</p>
<p><strong>F1度量</strong>：（用于为查准率，查全率加入不同的考虑权重，而非同等看待）</p>
<p>查准率和查全率的 调和平均数 的倒数:  注意调和平均数的性质！ 调和平均数有惩罚机制，会更靠近较小值（重视较小值）我们引入这样的惩罚机制就不会使得过小的值发不出声音，从而使评估变得更准确。</p>
<p>$$\frac{1}{F1} &#x3D; \frac{1}{2}(\frac{1}{P}+\frac{1}{R})$$</p>
<p><strong>改进</strong>： 引入权重系数$\beta$ 作为超参数，看到底倾向于哪个量</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://i-blog.csdnimg.cn/blog_migrate/9715a1fe99696322547c53f1edeb01ac.png#pic_center"
                      alt="Fβ度量"
                ></p>
<h4 id="宏-微查准率，查全率"><a href="#宏-微查准率，查全率" class="headerlink" title="宏&#x2F;微查准率，查全率"></a>宏&#x2F;微查准率，查全率</h4><p>若能得到多个混淆矩阵 : (例如多次训练&#x2F;测试的结果，多分类的两两混淆矩阵)</p>
<p>宏查准率就是评判所有的混淆矩阵的综合查准率。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://bluewhale-33.oss-cn-nanjing.aliyuncs.com/image-20241004181522045.png"
                      alt="image-20241004181522045"
                ></p>
<h4 id="ROC-AUC"><a href="#ROC-AUC" class="headerlink" title="ROC AUC"></a>ROC AUC</h4><p>ROC 曲线，即接收者操作特征曲线 用来评价二分类模型性能的常用图形工具。它通过显示真阳性率（True Positive Rate，简称 TPR）与假阳性率（False Positive Rate，简称 FPR）之间的权衡来帮助我们理解模型的分类能力。</p>
<p>AUC 曲线下面积（Area Under Curve），是 ROC 曲线下面积的一个数值表示。它提供了一个定量的指标，用来衡量分类模型的整体表现。AUC 值范围从 0 到 1，值越大表示模型性能越好</p>
<h5 id="为何需要-ROC-AUC"><a href="#为何需要-ROC-AUC" class="headerlink" title="为何需要 ROC&#x2F;AUC"></a>为何需要 ROC&#x2F;AUC</h5><p>在分类任务中，特别是当数据集类别不平衡时，单纯依赖准确率（Accuracy）可能会造成误导。假设我们有一个武侠元素的数据集，其中 95% 的样本是普通弟子，5% 的样本是高手。<strong>则若总是预测所有样本为普通弟子，模型的准确率就为 95%，看起来表现很好，但实际上它根本无法识别高手</strong>，是一个毫无用处的分类器。</p>
<p>分类器为每一个样本给予一个实值，如果这个值大于分类阈值则为正类，小于则为负类。我们可以将预测的实值从可能性大小进行排序，然后用分类阈值进行截断。<strong>ROC就是测量这个排序的性能好坏的。</strong></p>
<h5 id="如何绘制ROC"><a href="#如何绘制ROC" class="headerlink" title="如何绘制ROC"></a>如何绘制ROC</h5><p>给定m+个正例，m-个反例。 最开始先将分类阈值设为最大，（即全部预测反例。然后将分类阈值依次设置为每一个样例的预测值，即依次将每一个样例预测为正例，如果为真正例，则坐标向上移动 变为$(x,y+\frac{1}{m^+})$；假正例则向右移动 变为$(x+\frac{1}{m^-},y)$。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://i-blog.csdnimg.cn/blog_migrate/347a58dc212c5fe33ebac96f17bb0515.gif"
                      alt="img"
                ></p>
<h4 id="非均等代价"><a href="#非均等代价" class="headerlink" title="非均等代价"></a>非均等代价</h4><p>犯不同的错误往往会造成不同的损失 此时需考虑“非均等代价”(unequal cost)</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://bluewhale-33.oss-cn-nanjing.aliyuncs.com/image-20241004183705538.png"
                      alt="image-20241004183705538"
                ></p>
<p>代价敏感错误率：$cost_{01}:cost_{10}&#x3D;5:1$ 预测错误的代价是不同的</p>
<p><strong><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://bluewhale-33.oss-cn-nanjing.aliyuncs.com/image-20241004183725351.png"
                      alt="image-20241004183725351"
                ></strong></p>
<h3 id="比较检验"><a href="#比较检验" class="headerlink" title="比较检验"></a>比较检验</h3><p>在某种度量下取得评估结果后，是否可以直接比较以评判优劣？<br>NO !  因为：</p>
<ul>
<li>测试性能不等于泛化性能</li>
<li>测试性能随着测试集的变化而变化</li>
<li>很多机器学习算法本身有一定的随机性</li>
</ul>
<p>假设检验：计算显著性</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://bluewhale-33.oss-cn-nanjing.aliyuncs.com/image-20241004184851237.png"
                      alt="image-20241004184851237"
                ></p>
<p>回归任务中，均值误差可以分解为：</p>
<p>偏差（真实输出与期望输出的差别 bias）</p>
<p>方差（同样大小训练集下输出变动 variance）</p>
<p>系统误差（训练数据本身的误差）</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://bluewhale-33.oss-cn-nanjing.aliyuncs.com/image-20241004185009640.png"
                      alt="image-20241004185009640"
                ></p>
<h4 id="偏差-方差窘境"><a href="#偏差-方差窘境" class="headerlink" title="偏差-方差窘境"></a>偏差-方差窘境</h4><p>一般而言，偏差与方差存在冲突：</p>
<ul>
<li>训练不足时，学习器拟合能力不强，偏差主导</li>
<li><strong>随着训练程度加深，学习器拟合能力逐渐增强，方差逐渐主导</strong></li>
<li>训练充足后，学习器的拟合能力很强，方差主导</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://bluewhale-33.oss-cn-nanjing.aliyuncs.com/image-20241004185158982.png"
                      alt="image-20241004185158982"
                ></p>
<h5 id="如何减少高偏差"><a href="#如何减少高偏差" class="headerlink" title="如何减少高偏差"></a>如何减少高偏差</h5><ul>
<li>结合数据其他的特征，来<strong>提高模型的精度</strong></li>
<li><strong>增加训练的迭代次数</strong>，使得模型可以学习更加复杂的数据</li>
<li><strong>避免使用高偏差的算法</strong>，如线性回归、逻辑回归、判别分析等，而是使用<strong>非线性算法</strong>，如K-近邻、支持向量机、决策树等</li>
<li>在不同程度上<strong>减少正则化</strong>，以帮助模型更有效地学习训练集，<strong>并防止欠拟合</strong></li>
</ul>
<h5 id="如何减少高方差"><a href="#如何减少高方差" class="headerlink" title="如何减少高方差"></a>如何减少高方差</h5><ul>
<li><strong>减少</strong>模型中<strong>特征</strong>的数量</li>
<li>将当前模型<strong>替换为更简单的模型</strong></li>
<li><strong>增加训练数据的多样性</strong>以平衡模型的复杂度和数据结构</li>
<li><strong>避免使用高方差算法</strong>（支持向量机、决策树、K近邻等），而<strong>选择低方差算法</strong>，如线性回归、逻辑回归和线性判别分析</li>
<li>进行<strong>超参数调优以避免过拟合</strong></li>
<li><strong>增加输入的正则化</strong>以减少模型的复杂度并防止过拟合</li>
<li><strong>使用新的模型架构</strong>（如果其他方法不起作用，应将其视为最后的手段）</li>
</ul>
<h2 id="决策树"><a href="#决策树" class="headerlink" title="决策树"></a>决策树</h2><p>基于树进行决策，每个内部节点对应于一个属性的“测试”，边是测试结果，叶节点表示一个最终的预测结果。</p>
<p><strong><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://bluewhale-33.oss-cn-nanjing.aliyuncs.com/image-20241004190411393.png"
                      alt="image-20241004190411393"
                ></strong></p>
<p><strong>学习过程：通过对训练样本的分析确定一个“划分属性”（内部节点所对应的属性）</strong></p>
<p><strong>预测过程：将测试实例从根节点开始，沿着划分属性构成的”判定测试序列“下行，直到叶节点</strong></p>
<h4 id="学习基本流程"><a href="#学习基本流程" class="headerlink" title="学习基本流程"></a>学习基本流程</h4><p>策略：<strong>分而治之</strong>；自根到叶的递归过程，</p>
<p>停止条件：当前节点包含的样本都是同一个类别 当前的属性为空，所有样本在所有属性上的集合为空。</p>
<p>从属性集合A中获取最优划分属性$a^*$</p>
<h3 id="划分度量"><a href="#划分度量" class="headerlink" title="划分度量"></a>划分度量</h3><h6 id="在每一个节点选择什么属性进行测试，才能让其分支节点所包含的样本属于同一类别？换句话说，如何才能让被分开的样本尽可能不同，而分为一类的样本尽可能相似？"><a href="#在每一个节点选择什么属性进行测试，才能让其分支节点所包含的样本属于同一类别？换句话说，如何才能让被分开的样本尽可能不同，而分为一类的样本尽可能相似？" class="headerlink" title="在每一个节点选择什么属性进行测试，才能让其分支节点所包含的样本属于同一类别？换句话说，如何才能让被分开的样本尽可能不同，而分为一类的样本尽可能相似？"></a>在每一个节点选择什么属性进行测试，才能让其分支节点所包含的样本属于同一类别？换句话说，如何才能让被分开的样本尽可能不同，而分为一类的样本尽可能相似？</h6><h4 id="信息增益"><a href="#信息增益" class="headerlink" title="信息增益"></a>信息增益</h4><p><strong>信息熵</strong>：度量样本集合纯度的指标，越小，纯度越高，类别越相似。</p>
<p>信息熵的定义：假设当前样本集合D共K类样本，第k类样本所占的比例为$p_k$ 。</p>
<p>$$Ent(D) &#x3D; -\sum^K_{k&#x3D;1}p_klog_2p_k$$</p>
<p>如果某一个属性选择的很好，依照该属性划分完的样本信息熵应该很高。</p>
<p>信息增益：可以通过划分前的信息熵减去划分后的信息熵来得到信息增益（这就是划分好坏的度量）</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://bluewhale-33.oss-cn-nanjing.aliyuncs.com/image-20241005110845495.png"
                      alt="image-20241005110845495"
                ></p>
<p>例如：对于西瓜来说，纹理$\alpha$是一个可以用来作为划分的属性，它的取值有{清晰，稍糊，模糊}三种，现在共有17个西瓜作为样本D 。易于计算划分之前的信息熵（直接根据好坏分类计算），划分之后的信息熵通过看<strong>属性各个取值下</strong>的<strong>西瓜比例，好瓜比例，坏瓜比例</strong>代入公式即可。<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://bluewhale-33.oss-cn-nanjing.aliyuncs.com/image-20241005111244620.png"
                      alt="image-20241005111244620"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://bluewhale-33.oss-cn-nanjing.aliyuncs.com/image-20241005111513892.png"
                      alt="image-20241005111513892"
                ></p>
<h4 id="增益率"><a href="#增益率" class="headerlink" title="增益率"></a>增益率</h4><p>信息增益缺点： 对可取值数目多的属性更偏好，如果将编号作为属性，编号的信息增益很大（确实是完全分开了，每个类别都很纯，只有一个瓜）。</p>
<p><strong>作为改进</strong>——增益率：<strong>将信息熵除以一个IV（a）</strong></p>
<p>$$Gain_ratio(D,a) &#x3D; \frac{Gain(D,a)}{IV(a)}$$</p>
<p>其中：$IV(a) &#x3D; -\sum^{V}_{v&#x3D;1}\frac{D^V}{D}log_2\frac{D^V}{D} $ 也就是<strong>属性本身的信息熵</strong></p>
<p>属性a的可取值数目多，即V越大，则IV（a）更大。</p>
<p>启发式：先从划分属性中找出信息上增益高于其他水平的，从其中选取增益率最高的（<strong>防止对取值较少的属性偏好</strong>）。</p>
<h4 id="基尼指数"><a href="#基尼指数" class="headerlink" title="基尼指数"></a>基尼指数</h4><p>信息增益和增益率都要<strong>计算对数</strong>。</p>
<p>基尼指数只需要<strong>计算比例</strong>。</p>
<p>$p_k$：样本点属于第𝑘类的概率</p>
<p>$$Gini(D) &#x3D; \sum^{|y|}<em>{k&#x3D;1}\sum</em>{k_<em>\neq k}p_kp_{k_</em>} $$</p>
<p>$$Gini(D )&#x3D; 1-\sum^{|y|}_{k&#x3D;1}p_k^2$$</p>
<p><strong>反映了从集合D中随机抽取两个样例，其类别标记不一致的概率。该指数越小，表示集合D纯度越高，即划分纯度越高。</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://bluewhale-33.oss-cn-nanjing.aliyuncs.com/image-20241008110743266.png"
                      alt="image-20241008110743266"
                ></p>
<p>所有候选属性集合中，选择使得划分后基尼指数最小的那个属性。</p>
<p>$$a^* &#x3D; argmin_{a\in A}Gini_index(D,a)$$</p>
<h3 id="剪枝"><a href="#剪枝" class="headerlink" title="剪枝"></a>剪枝</h3><ul>
<li><p><strong>划分选择的各种方法</strong>在大多数情况下<strong>只影响决策树大小</strong>，但对<strong>泛化性能的影响不大</strong>，</p>
</li>
<li><p><strong>剪枝方法和程度</strong>对决策树<strong>泛化性能影响非常大</strong>。剪枝<strong>是对抗“过拟合”的主要手段</strong>。</p>
</li>
<li><p>为了尽可能的正确分类样本，会导致决策树分支过多，剪枝来减少过拟合。</p>
</li>
</ul>
<p><strong>预剪枝</strong>：提前剪掉一些分支的生长。</p>
<p><strong>后剪枝</strong>：对完全树”回头“进行剪枝。</p>
<p>剪枝过程中要评估剪枝前后决策树的优劣。</p>
<h4 id="预剪枝"><a href="#预剪枝" class="headerlink" title="预剪枝"></a>预剪枝</h4><p>对每一个节点<strong>比对划分前后的预测精度</strong>：如果划分后的精度<strong>增大</strong>，则进行划分，否则禁止划分。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://bluewhale-33.oss-cn-nanjing.aliyuncs.com/image-20241005113928722.png"
                      alt="image-20241005113928722"
                ></p>
<h4 id="后剪枝"><a href="#后剪枝" class="headerlink" title="后剪枝"></a>后剪枝</h4><p><strong>自底向上</strong>：如果将<strong>倒数第二层一个内部节点替换为叶子节点</strong>，如果验证集的精度上升，则剪枝，否则不剪枝。</p>
<p><strong><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://bluewhale-33.oss-cn-nanjing.aliyuncs.com/image-20241005114351760.png"
                      alt="image-20241005114351760"
                ></strong></p>
<h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><p>预剪枝：测试时间开销降低，训练时间开销降低<br>后剪枝：测试时间开销降低，训练时间开销增加</p>
<p>预剪枝：过拟合风险降低，欠拟合风险增加<br>后剪枝：过拟合风险降低，欠拟合风险基本不变</p>
<p>泛化性能：后剪枝通常优于预剪枝</p>
<h3 id="连续值属性处理"><a href="#连续值属性处理" class="headerlink" title="连续值属性处理"></a>连续值属性处理</h3><p>基本思路：连续数值离散化。</p>
<p>常见做法：二分法</p>
<p>n个属性值<strong>从小到大排序</strong>，可形成n-1个区间，<strong>在这n-1个区间中每个可以选择1个阈值作为划分点</strong>，共n-1种样本集合的划分方式。当选择了一个阈值进行划分时，此时就已经和离散数值处理一样了，就看哪种划分方式最好即可 。</p>
<p>如：密度阈值&#x3D;0.3，就是将0.3当作一个阈值，分出大于 小于0.3的两个分支。</p>
<h3 id="缺失值处理"><a href="#缺失值处理" class="headerlink" title="缺失值处理"></a>缺失值处理</h3><ol>
<li>如何划分属性（内部节点中的测试属性该选哪个）</li>
<li>给定划分属性，但是缺少属性值，（走哪个分支）</li>
</ol>
<p>使用完全没有缺失值的样例是不现实的，会浪费很多数据。所以我们分析某一个属性的时候，只看该属性下没有缺失值的样本即可。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://bluewhale-33.oss-cn-nanjing.aliyuncs.com/image-20241005154416507.png"
                      alt="image-20241005154416507"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://bluewhale-33.oss-cn-nanjing.aliyuncs.com/image-20241005154442825.png"
                      alt="image-20241005154442825"
                ></p>
<p><strong><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://bluewhale-33.oss-cn-nanjing.aliyuncs.com/image-20241005154458338.png"
                      alt="image-20241005154458338"
                ></strong></p>
<p>关键是这里的$\widetilde r_v$ 和 $\rho$ ，是无缺失值样例的占比，加入这个权重即可。</p>
<p>每个决策树对应一个规则集，可解释性比较高。</p>
<h3 id="拓展-轴平行划分"><a href="#拓展-轴平行划分" class="headerlink" title="拓展 轴平行划分"></a>拓展 轴平行划分</h3><p>每个节点只讨论一个属性时 就是单变量决策树。</p>
<p>多变量决策树：例如斜决策树， 不失为不是为每个非叶节点进行最优属性划分，而是建设一个线性分类器</p>
<p>还可以在节点嵌入神经网络和SVM进行混合决策。</p>
<h2 id="KNN-k近邻"><a href="#KNN-k近邻" class="headerlink" title="KNN k近邻"></a>KNN k近邻</h2><h3 id="距离度量"><a href="#距离度量" class="headerlink" title="距离度量"></a>距离度量</h3><p>例如欧氏距，余弦相似性，马氏距离等等。（在预备知识提到过）</p>
<h3 id="k近邻分类器"><a href="#k近邻分类器" class="headerlink" title="k近邻分类器"></a>k近邻分类器</h3><p>算法流程</p>
<ol>
<li><p>计算测试样本$\overline{x}$和$D_{train}$中所有训练样本之间的距离d</p>
</li>
<li><p>对所有距离值（相似度值）进行升序或者降序排列</p>
</li>
<li><p>选择k个最近的训练样本</p>
</li>
<li><p>再用投票法，将近邻中样本数最多的标签分配给$\overline{x}$</p>
</li>
</ol>
<p>k取值的影响</p>
<ul>
<li>k取奇数值，避免平局</li>
<li>k取不同的值，分类结果可能不同</li>
<li>k值较小，对噪声敏感，模型复杂 容易过拟合（直觉上想，离得越近影响越大，k小一点可以得到比较好的分类，但是对噪声敏感）</li>
<li>k值大，对噪声不敏感，整体模型变得简单，容易欠拟合（比如取全集，怎么测试都输出一个类型，无法正常分类）</li>
</ul>
<h3 id="最近邻分类器（1-NN）"><a href="#最近邻分类器（1-NN）" class="headerlink" title="最近邻分类器（1-NN）"></a>最近邻分类器（1-NN）</h3><p>当k&#x3D;1时的KNN</p>
<h3 id="泛化错误率"><a href="#泛化错误率" class="headerlink" title="泛化错误率"></a>泛化错误率</h3><p>最近邻分类器的错误率（测试样本为x，最近邻为z）</p>
<p>$$P(err) &#x3D; 1 - \sum_{c\in y}P(c|x)P(c|z)$$</p>
<p>最优贝叶斯分类：</p>
<p>最近邻分类器的泛化错误率，不超过贝叶斯错误率的两倍。</p>
<h3 id="K-近邻回归"><a href="#K-近邻回归" class="headerlink" title="K-近邻回归"></a>K-近邻回归</h3><p>最后一步不同：</p>
<p>将距离值的倒数作为权重，然后将k个邻近的标签值加权平均，作为$\overline{x}$的预测值</p>
<h3 id="近邻平滑"><a href="#近邻平滑" class="headerlink" title="近邻平滑"></a>近邻平滑</h3><p>核平滑法：<strong>核函数</strong></p>
<p>二次核，次方核，高斯核</p>
<h3 id="讨论"><a href="#讨论" class="headerlink" title="讨论"></a>讨论</h3><p>k-NN是典型的“懒惰学习”</p>
<p>训练阶段仅仅是把样本保存下来，训练时间开销是0，等到测试样本在开始处理。</p>
<p>SVM，CNN，在训练阶段进行学习处理的方法，这类方法在训练期间构造一个通用的，输出无关的目标函数。</p>
<p>优点：精度高，对异常值不敏感，不用假定输入样本</p>
<p>缺点：计算复杂度高（距离函数计算慢），空间复杂度大（训练集大）</p>
<p>测试时间复杂度：计算距离时间+排序时间</p>
<h3 id="降低近邻计算"><a href="#降低近邻计算" class="headerlink" title="降低近邻计算"></a>降低近邻计算</h3><p>维诺图</p>
<p>每个维诺图都是一个凸多边形，画好每一个分类的图，看看测试点是否会落到这个点中</p>
<h4 id="KD树"><a href="#KD树" class="headerlink" title="KD树"></a>KD树</h4><p>对K维空间中的实例点进行计算，</p>
<p>构造流程：</p>
<ul>
<li><p>确定split域 计算每一个特征维度的方差，方差最大的维度即为spilt域的值。（x方向方差大，就竖着划分，以中位数为界画一条竖线，将样本空间划分为两个部分。）</p>
</li>
<li><p>确定Node-data域，数据集点集按照其spilt域的值排序。中位数的数据点击被选为Node-data</p>
</li>
<li><p>对剩下的数据点进行划分，确定左右子空间</p>
</li>
<li><p>递归，每个字空间继续进行空间划分，直到空间中只包含一个数据点</p>
</li>
</ul>
<p>kd树搜索：</p>
<ol>
<li>二叉搜索</li>
<li>到达叶子节点就选择为当前最优，</li>
<li>回溯</li>
<li>分析完根结点的所有子节点，结束分析</li>
</ol>
<p>例子：</p>
<h3 id="降维"><a href="#降维" class="headerlink" title="降维"></a>降维</h3><p>通过数学变换将高维属性空间进行转变，成为一个低维属性空间。（增加距离的计算速度）</p>
<h3 id="近似最近邻"><a href="#近似最近邻" class="headerlink" title="近似最近邻"></a>近似最近邻</h3><p>搜索可能是近邻的数据项而不再是只局限于返回最可能的数据项，在牺牲可接受范围内的精度的情况下获得最近邻。</p>
<h3 id="哈希"><a href="#哈希" class="headerlink" title="哈希"></a>哈希</h3><p>通过编码的方式进行降低代价</p>
<h2 id="SVM-支持向量机"><a href="#SVM-支持向量机" class="headerlink" title="SVM 支持向量机"></a>SVM 支持向量机</h2><p>生成式模型</p>
<p>判别式模型（SVM）</p>
<h3 id="感知机"><a href="#感知机" class="headerlink" title="感知机"></a>感知机</h3><p>将训练样本分开的超平面有很多，哪一个更好</p>
<p>“正中间的”：鲁棒性最好，容错率高，泛化能力最强</p>
<h3 id="线性支持向量机"><a href="#线性支持向量机" class="headerlink" title="线性支持向量机"></a>线性支持向量机</h3><h4 id="间隔和支持向量"><a href="#间隔和支持向量" class="headerlink" title="间隔和支持向量"></a>间隔和支持向量</h4><p>一个点（样例）对应的间隔margin是其到分界线的垂直距离。</p>
<p>SVM<strong>最大化</strong>（所有训练样本的）<strong>最小间隔margin</strong></p>
<p>具有最小间隔的点称为支持向量</p>
<p>#聚类 无监督学习</p>
<p>聚类的好坏没有绝对标准，聚类采用某一种偏好来进行聚类划分。</p>
<p>聚类（簇、类）。数据对象的集合。同一个类中，数据对象是相似的，不同聚类中，数据对象是不相似的</p>
<p>聚类算法：根据给定的相似性评价标准，将一个数据集合分出几个聚类。</p>
<ul>
<li>簇之间交集为空集</li>
<li>并集是样本集合D</li>
</ul>
<p>##聚类依据</p>
<p>将整个数据集中每个<strong>样本的特征向量</strong>看作是<strong>分布到特征空间中的一些点</strong>，<strong>点与点之间的距离</strong>（不一定是欧氏距离）可作为相似性度量标准。根据距离函数的大小进行聚类。</p>
<p>好的聚类算法，类之间不相似，类内部高相似性。</p>
<p>根据数据的相似性和距离进行划分。</p>
<p>##粒度对聚类的影响</p>
<p>聚类的关键：</p>
<ul>
<li><p>特征的选取或者设计，特征选择的好，容易区分。</p>
</li>
<li><p>距离度量函数的选择</p>
</li>
</ul>
<p>数据点的分布也是一群一群的，同一群样本密集，这样容易聚类。不同特征样本混在一起不容易聚类。</p>
<h2 id="距离度量-1"><a href="#距离度量-1" class="headerlink" title="距离度量"></a>距离度量</h2><p>度量同样本之间的相似性，和不同样本点之间的差异性</p>
<p>常用度量函数：各种距离函数。（之前提到过）</p>
<h2 id="类的定义"><a href="#类的定义" class="headerlink" title="类的定义"></a>类的定义</h2><p>类的定义有很多种，其中混合了人为规范性。定义的好不好要看实际情况</p>
<p>还需要基于数值的准则函数。如果聚类准则函数选择的好，聚类的质量就会高</p>
<h2 id="聚类准则"><a href="#聚类准则" class="headerlink" title="聚类准则"></a>聚类准则</h2><h3 id="直接试探法：凭感觉和经验定义一种度量的函数（人为告诉一个规则）"><a href="#直接试探法：凭感觉和经验定义一种度量的函数（人为告诉一个规则）" class="headerlink" title="直接试探法：凭感觉和经验定义一种度量的函数（人为告诉一个规则）"></a>直接试探法：凭感觉和经验定义一种度量的函数（人为告诉一个规则）</h3><ul>
<li><p>设置距离阈值m</p>
</li>
<li><p>任取一个样本点作为聚类中心初始值</p>
</li>
<li><p>计算其他样本点和中心的距离</p>
</li>
<li><p>若大于m，则确定一个新的聚类中心，否则即属于该聚类中心</p>
</li>
<li><p>假设已经有两个聚类中心，则第三个样本距离这两个样本都大于m，则称为新的聚类中心。</p>
</li>
</ul>
<h4 id="影响因素："><a href="#影响因素：" class="headerlink" title="影响因素："></a>影响因素：</h4><ul>
<li>初始点不同</li>
<li>阈值T不同</li>
</ul>
<h4 id="优化："><a href="#优化：" class="headerlink" title="优化："></a>优化：</h4><p>最大最小距离思想（另一种算法）：</p>
<p>对于聚类中心的选择有改变：先选择距离初始聚类中心最远的点当第二个聚类中心。</p>
<p>###准则函数法： 聚完类之后，根据准则函数计算损失函数，告诉聚类模型，优化模型</p>
<p>$J &#x3D; \sum\sum$</p>
<p>J代表c个聚类全部样本和对应类别均值之间的距离和。</p>
<h3 id="系统聚类法"><a href="#系统聚类法" class="headerlink" title="系统聚类法"></a>系统聚类法</h3><p>将数据样本按距离准则逐步分类，类别由多到少，直到获得合适的分类要求为止。</p>
<p>算法：</p>
<p>主要的计算准则：</p>
<h3 id="动态聚类法K-means"><a href="#动态聚类法K-means" class="headerlink" title="动态聚类法K-means"></a>动态聚类法K-means</h3><p>首先选择若干个点作为样本中心，然后按照某种聚类准则进行划分，使得聚类向样本中心靠拢</p>
<p>算法：</p>
<ol>
<li>选择聚类数量k</li>
<li>初始化聚类中心（随机选择k个点）</li>
<li>对每个样本点，到这k个聚类中心的距离，将样本点划分到离他最近的聚类中心。</li>
<li>重新计算聚类中心，为属于该聚类所有样本的均值中心。</li>
</ol>
<p>影响因素：</p>
<ul>
<li>聚类数目</li>
<li>聚类中心的初始分布</li>
<li>样本分布的几何性质</li>
</ul>
<p>实际中需要试探不同的K值和选择不同的聚类中心初始分布。</p>
<p>适合分类数目已知的情况</p>
<h4 id="优化-K-means"><a href="#优化-K-means" class="headerlink" title="优化 K-means++"></a>优化 K-means++</h4><p>每个聚类中心应该分的足够开。</p>
<h4 id="ISODATA算法"><a href="#ISODATA算法" class="headerlink" title="ISODATA算法"></a>ISODATA算法</h4><p>过程中根据各个类别的实际情况进行分裂和合并两种操作来进行聚类中心调整</p>
<ol>
<li>判断类别中的样本数量是不是小于M，如果小于就减少一个聚类中心，然后将这个聚类中的各个样本分到其他聚类中心。<br>如果样本数量太大，</li>
</ol>
<p>合并：计算聚类中心两两之间的距离，若两个类别之间的中心距离小于一个阈值，就合并为一个类。新中心选在样本数量多的一侧</p>
<p>分裂：计算样本在各个维度下的方差。类别中样本方差最大的，就进行分裂操作。</p>
<h3 id="聚类评价"><a href="#聚类评价" class="headerlink" title="聚类评价"></a>聚类评价</h3><ul>
<li>聚类中心之间的距离</li>
<li>聚类中的样本数量</li>
<li>聚类内样本的距离方差</li>
</ul>
<p>外部指标：</p>
<p>内部指标：</p>
<p>紧密度：计算每个xi和各自聚类中心的距离的求和，然后取一个平均。</p>
<p>间隔度：</p>
<p>戴维森堡丁指数：</p>
<p>邓恩指数：</p>
<h1 id="自然语言处理"><a href="#自然语言处理" class="headerlink" title="自然语言处理"></a>自然语言处理</h1><p>理性主义——经验主义——深度学习</p>
<p>他们的可解释性和性能比例是相反的。</p>
<h3 id="基于规则的方法"><a href="#基于规则的方法" class="headerlink" title="基于规则的方法"></a>基于规则的方法</h3><p>进行规则形式定义，设置一系列规则进行翻译</p>
<p>如： if 源语言主语 &#x3D; 我 then 翻译为 I</p>
<h3 id="基于机器学习的方法"><a href="#基于机器学习的方法" class="headerlink" title="基于机器学习的方法"></a>基于机器学习的方法</h3><p>数据创建——数据预处理（词汇分析，结构分析，语义分析）——特征构建（）——模型学习</p>
<p>将自然语言处理变为一种分类任务：在此基础上根据任务特性构建特征表示</p>
<h3 id="深度学习方法"><a href="#深度学习方法" class="headerlink" title="深度学习方法"></a>深度学习方法</h3><p>将特征构建和模型学习合并。不做后处理，通过优化算法，自动的学习出好的特征表示。</p>
<h3 id="基于大模型方式"><a href="#基于大模型方式" class="headerlink" title="基于大模型方式"></a>基于大模型方式</h3><p>大规模模型构建——通用能力注入——特定任务使用</p>
<p>使用一个基本的大模型，增加分类层（预训练+微调）</p>
<h2 id="文本规范化"><a href="#文本规范化" class="headerlink" title="文本规范化"></a>文本规范化</h2><p>句子切分——词语切分——词语规范化</p>
<h3 id="词语切分"><a href="#词语切分" class="headerlink" title="词语切分"></a>词语切分</h3><p>将一句话中每一个词语都分开。</p>
<p>挑战：歧义分割？分词规范（如何分）；未登录词识别（新词）</p>
<p>最大匹配分词算法：</p>
<p>最佳匹配算法：</p>
<p>分词工具jieba</p>
<h3 id="词语规范化"><a href="#词语规范化" class="headerlink" title="词语规范化"></a>词语规范化</h3><p>将词语转化为标准形式，相同语义词语归一化——They-&gt;they</p>
<h5 id="One-Hot编码"><a href="#One-Hot编码" class="headerlink" title="One-Hot编码"></a>One-Hot编码</h5><p>每个词表示为一个向量，向量的维度就是词表的大小</p>
<p>忽视了词频，没有权重</p>
<h5 id="TF-IDF编码-词频-逆文档频率篇章表示"><a href="#TF-IDF编码-词频-逆文档频率篇章表示" class="headerlink" title="TF-IDF编码 词频*逆文档频率篇章表示"></a>TF-IDF编码 词频*逆文档频率篇章表示</h5><p>词汇频率：词语在文档中的频率</p>
<p>逆文档频率：在整个语料库中的频率</p>
<p>两者相乘</p>
<p>IF &#x3D;</p>
<p>$$IDF(t)&#x3D;  log\frac{}{}$$</p>
<p>Onehot和TF-IDF缺点</p>
<p>频率的缺陷——词是独立计算的没有关联——特征稀疏，导致维度灾难</p>
<h5 id="Word-Embedding"><a href="#Word-Embedding" class="headerlink" title="Word-Embedding"></a>Word-Embedding</h5><p>将词语映射到特征空间中的稠密矩阵（固定维度）</p>
<p><strong>语义相似的词语空间距离更近</strong>。特征值的相减和相加就能进行词语的计算（语义和语法的相似度）。</p>
<p>分布式表示：通过训练将词语设置为固定长度的向量，</p>
<h6 id="词向量：每一个词语都是一个低位的稠密向量-Word2Vec算法使用浅层神经网络实现"><a href="#词向量：每一个词语都是一个低位的稠密向量-Word2Vec算法使用浅层神经网络实现" class="headerlink" title="词向量：每一个词语都是一个低位的稠密向量 Word2Vec算法使用浅层神经网络实现"></a>词向量：每一个词语都是一个低位的稠密向量 Word2Vec算法使用浅层神经网络实现</h6><h4 id="上下文"><a href="#上下文" class="headerlink" title="上下文"></a>上下文</h4><p>滑动窗口——<strong>将词语附近的其他词语划分到一个窗口中</strong>，通过其他词语得到这个词的语义。</p>
<h5 id="前馈神经网络"><a href="#前馈神经网络" class="headerlink" title="前馈神经网络"></a>前馈神经网络</h5><p>定义参数化映射：$y &#x3D; f(x,t)$</p>
<p>通过风险最小化和正则化样本上学习参数t，添加到函数中</p>
<p>神经元没有反馈链接，所以是前馈。多层的连续的非线性函数。</p>
<p>有一个语料库，遍历语料库中每一个位置t上的词语，这称为中心词c，窗口以内，c之外的词语就是上下文词语。</p>
<h4 id="ship-gram"><a href="#ship-gram" class="headerlink" title="ship gram"></a>ship gram</h4><p>给出一个中心词，以此预测他的上下文内容。</p>
<ol>
<li>初始化：独热向量x</li>
<li>根据查询表获得向量h，查询表等同于输入的权重矩阵，操作为$h &#x3D; W^Tx$</li>
<li>每个位置预测 $p &#x3D; softmax(W^Th)$ 维度&#x3D;词典大小</li>
<li>根据该位置真实的独热向量和p计算损失值loss</li>
</ol>
<h4 id="CBOW"><a href="#CBOW" class="headerlink" title="CBOW"></a>CBOW</h4><p>连续词袋模型。</p>
<p>更好的表征？</p>
<p>现有词向量的缺点：都是静态的</p>
<h5 id="预训练"><a href="#预训练" class="headerlink" title="预训练"></a>预训练</h5><p>通过预训练嵌入更多的背景知识。引入上下文有关的信息。</p>
<p>预训练模型中的encoder结构实现动态向量表示。</p>
<p>遍历语料库，自主产生伪标签嵌入词向量。</p>
<h6 id="要求"><a href="#要求" class="headerlink" title="要求"></a>要求</h6><p>收集大量数据。</p>
<p>基于tansformer的预训练模型。</p>
<h6 id="BERT-预训练模型"><a href="#BERT-预训练模型" class="headerlink" title="BERT 预训练模型"></a>BERT 预训练模型</h6><p>transformer编码器端</p>
<p>预训练任务：</p>
<p>掩码语言模型：遮蔽文本中k%词语，让模型基于上下文预测被遮蔽的词语。</p>
<p>K的选择有讲究：k小，数据量少训练昂贵。K大被遮蔽的太多 15%最好。</p>
<p>下一句预测：判断两句话A，B是否有关系：B是A的下一句话。</p>
<h6 id="微调"><a href="#微调" class="headerlink" title="微调"></a>微调</h6><p>情感分类使用[CLS]向量作为文本整体的表示。以此预测类别</p>
<p>SQuAD问答：</p>
<h2 id="支持向量机"><a href="#支持向量机" class="headerlink" title="支持向量机"></a>支持向量机</h2><p>###感知机</p>
<p>###线性支持向量机</p>
<p>###非线性支持向量机</p>
<p>数据集是非线性可分：将数据投影到高维度空间，转变成线性可分的问题。</p>
<p>特征空间映射：将样本从原始维度映射到高位空间。</p>
<p>内积：线性和非线性的联系</p>
<p>$x&#x3D;(x_1,x_2) $</p>
<p>$z&#x3D;(z_1,z_2)$</p>
<p>x和z的内积K(x,z)：计算二维空间中相似度</p>
<p>K是核函数：$K(x,y) &#x3D; \phi(x^T)\phi(y) $</p>
<p>现在有两个向量x，y：通过K(x,y)计算两者相似度：先将x，y映射到高位空间，</p>
<p>$\phi$是投影函数（特征空间）：将输入向量投影到一个空间中。可以是有限维度可以是无限维</p>
<h4 id="什么样的限制条件"><a href="#什么样的限制条件" class="headerlink" title="什么样的限制条件"></a>什么样的限制条件</h4><p>必须存在特征映射：才可以将非线性函数表示为特征空间中的内积。</p>
<p>Mercer条件（判断K是否是核函数）：两种断定方式</p>
<h3 id="核支持向量机"><a href="#核支持向量机" class="headerlink" title="核支持向量机"></a>核支持向量机</h3><p>核函数</p>
<p>对偶形式：$argmax\sum^n_{i&#x3D;1}a_i - \frac{1}{2}\sum^n_{i&#x3D;1}\sum^n_{j&#x3D;1}a_ia_jy_iy_jK(x_i,x_j)$</p>
<p>分类边界：$w &#x3D; \sum^n_{i&#x3D;1}a_iy_i\phi(x_i)$</p>
<p>怎样预测：</p>
<p>在对偶空间中，呈现内积的形式，替换成为核函数。</p>
<h4 id="非线性核函数"><a href="#非线性核函数" class="headerlink" title="非线性核函数"></a>非线性核函数</h4><p>超参数：如何确定C,$\gamma$</p>
<p>必须给定这些值 才能进行SVM学习，SVM本身不能学习</p>
<p>###多类支持向量机</p>
<p>多类：转化为2类</p>
<p>启发：<br>SVM从线性，二类，可分的情况开始</p>
<h2 id="神经网络"><a href="#神经网络" class="headerlink" title="神经网络"></a>神经网络</h2><p>连接强度调整量和输入输出乘积成正比。显然经常出现的模式将增强神经元之间的联系。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://bluewhale-33.oss-cn-nanjing.aliyuncs.com/image-20240713223829502.png"
                      alt="image-20240713223829502"
                ></p>
<p>还可以向sum加一个偏置常数$x_0$，权重为$w_0$</p>
<p>激活函数：决定是否放电（是否输出，或者输出值的大小）？</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://bluewhale-33.oss-cn-nanjing.aliyuncs.com/image-20240713224212475.png"
                      alt="image-20240713224212475"
                ></p>
<p>sigmoid始终有导数：而且一直小于1。容易造成梯度消失问题，指数计算代价大。</p>
<p>Relu在大于零的时候，倒数恒为1。所以梯度不会消失</p>
<h3 id="局限"><a href="#局限" class="headerlink" title="局限"></a>局限</h3><p>输入方面：线性求和 （非线性求和）</p>
<p>输出方面：单一值 (电脉冲)</p>
<p>更新频率：时钟周期（异步更新）</p>
<h3 id="感知机学习"><a href="#感知机学习" class="headerlink" title="感知机学习"></a>感知机学习</h3><p>非线性前馈式神经网络 最简单的结构</p>
<p>同层没有连接</p>
<p>不同层没有反馈</p>
<p>有下层往上层传递</p>
<p>输入输出都是离散值</p>
<p>由阈值函数决定其输出</p>
<h3 id="有监督的学习方式"><a href="#有监督的学习方式" class="headerlink" title="有监督的学习方式"></a>有监督的学习方式</h3><p>学习权重的过程，如果感知机结果不正确，就根据下面的公式进行更新。</p>
<p>$\Delta W_i &#x3D; \eta (y_i)-sign（\sum w_ix_i）x_i$</p>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>感知机是单层神经网络，无法分析非线性可分问题，如XOR异或</p>
<h3 id="多层感知机"><a href="#多层感知机" class="headerlink" title="多层感知机"></a>多层感知机</h3><p>一个隐藏层可以增加函数的非线性程度。非线性加权求和，非线性映射……不断循环。</p>
<p>将样本输入特征空间进行了投影：原本不好划分的点现在好划分了。</p>
<p>实际是特征检测算子：逐步发现可化训练数据的突出特征。</p>
<p>多层前馈神经网络：每一层之间是全连接的。没有同层或者跨层链接</p>
<p>具有非常强的表示能力，仅需一个隐藏层，就能以任意精度逼近任意复杂度的函数。</p>
<p>如何设置隐藏层神经元个数还是未决的（）。常用试错法。</p>
<p>输入的神经元是4个。就是有4个特征。10个中间隐藏层说明就是将4维特征投影到了10维空间。</p>
<h3 id="反向传播算法"><a href="#反向传播算法" class="headerlink" title="反向传播算法"></a>反向传播算法</h3><p>给定训练集D</p>
<p>输入：d维特征向量</p>
<p>输出：L个输出值</p>
<p>假设有q个隐藏层神经元</p>
<p>激活函数：sigmoid</p>
<p>总参数个数：(d+L+1)q+L （q和L都是偏置权重，剩下就是边的数量）</p>
<p>对于一个训练例（x，y）xy都是向量：实际输出是$\hat{y}$，代表标签</p>
<p>然后计算均方误差$E_k &#x3D; \frac{1}{2}\sum^L_{j&#x3D;1}(\hat{y}-y)^2$。越小越好。</p>
<p>BP是一个迭代学习算法：迭代的每一轮：</p>
<p>$v&lt;- v + \Delta v$ 。若$\Delta v$是负的</p>
<p>BP基于梯度下降策略，以目标的负梯度方向对参数做出调整</p>
<h3 id="卷积神经网络"><a href="#卷积神经网络" class="headerlink" title="卷积神经网络"></a>卷积神经网络</h3><h4 id="卷积"><a href="#卷积" class="headerlink" title="卷积"></a>卷积</h4><ul>
<li>特征提取</li>
<li>超参数</li>
<li>过滤器：3x3x3x95   95个滤波器，一个滤波器是3x3x3，核大小是3x3</li>
</ul>
<p>张量是三维，滤波器也是相同大小</p>
<p>将3x3的区域和图像对应大小的区域做点乘，然后往右移动一个像素，继续3x3对应的计算。（从上到下，从左到右），有多少个滤波器，就要多少个通道的输出。</p>
<h4 id="池化、下采样"><a href="#池化、下采样" class="headerlink" title="池化、下采样"></a>池化、下采样</h4><ul>
<li>减少参数</li>
<li>避免过拟合</li>
<li>扩大感受域</li>
</ul>
<p>抽取特征，将矩阵缩小。</p>
<p>####全连接层</p>
<ul>
<li>全局特征抽取</li>
<li>Softmax-layer 分类层</li>
</ul>
<p>池化层之后，将张量变为一个向量</p>
<p>向量维度很大，要乘以矩阵变为低维向量。</p>
<h4 id="Dropout"><a href="#Dropout" class="headerlink" title="Dropout"></a>Dropout</h4><p>对大神经网络进行平均的方法。最简单的情况下，每个神经元都以固定概率保留。</p>
<p>训练的过程中，网络结构在不断调整，相当于训练了很多神经网络符合而成的网络。类似于集成学习。</p>
<h4 id="Batch-Normalization"><a href="#Batch-Normalization" class="headerlink" title="Batch Normalization"></a>Batch Normalization</h4><h4 id="梯度-SGD"><a href="#梯度-SGD" class="headerlink" title="梯度(SGD)"></a>梯度(SGD)</h4><h2 id="模型轻量化"><a href="#模型轻量化" class="headerlink" title="模型轻量化"></a>模型轻量化</h2><p>减少机器学习、深度学习模型的计算量。</p>
<ul>
<li>减少模型大小</li>
<li>加快推理速度</li>
<li>保持相同精度</li>
</ul>
<p>量化——蒸馏——剪枝——二值化</p>
<h3 id="剪枝-pruning"><a href="#剪枝-pruning" class="headerlink" title="剪枝 pruning"></a>剪枝 pruning</h3><p>尝试修建 删除不重要的权重。</p>
<p>结构化剪枝（剪去一个维度块）——非结构化剪枝（一次剪一个通道）</p>
<h3 id="蒸馏"><a href="#蒸馏" class="headerlink" title="蒸馏"></a>蒸馏</h3><p>将大模型知识蒸馏到小的模型。</p>
<ol>
<li><p>知识</p>
</li>
<li><p>蒸馏算法<br>离线：</p>
</li>
<li><p>师生架构</p>
</li>
</ol>
<h3 id="量化"><a href="#量化" class="headerlink" title="量化"></a>量化</h3><p>将浮点计算转为低比特定制计算的方式。</p>
<h3 id="交叉熵损失函数"><a href="#交叉熵损失函数" class="headerlink" title="交叉熵损失函数"></a>交叉熵损失函数</h3><h3 id="回归损失"><a href="#回归损失" class="headerlink" title="回归损失"></a>回归损失</h3><p>L2-Norm ： $L_i &#x3D; || f-y_i||^2$</p>
<p>三元组损失，三元组包含三个样本：如分类样本，输入形式为$x_a,x_n,x_p$ xa是锚点，xn是负样本，xp是正样本。</p>
<p>排序，ranking</p>
<h2 id="深度学习技巧"><a href="#深度学习技巧" class="headerlink" title="深度学习技巧"></a>深度学习技巧</h2><p>数据增广：数据量比较少，如何得到更好的效果?mixup</p>
<p>水平翻转，随机裁剪，颜色抖动</p>
<p>预处理：如何初始化神经网络权重</p>
<p>Zero-center 正态化 PCA白花</p>
<p>初始化：</p>
<p>过滤器：大小如何定，一般是3x3</p>
<p>一般是2的指数</p>
<p>池化大小：2x2</p>
<p>学习率：模型影响最大。学习率大，训练的比较快，收敛的比较快</p>
<p>学习率小，收敛的慢。微调时学习率要小。</p>
<table>
<thead>
<tr>
<th></th>
<th>大数据量</th>
<th>比较少的数据量</th>
</tr>
</thead>
<tbody><tr>
<td>相似的数据集</td>
<td></td>
<td>线性分类器</td>
</tr>
<tr>
<td>非常不同的数据集</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>在预训练模型上微调</p>
<p>激活函数的选择</p>
<p>包含fc层或者是全连接层，或嵌入batch，导致网络的差异。</p>
<p>对学习的参数进行正则化：L2，L1，Max norm 防止过拟合</p>
<p>图像分析：在各个数据集上的精度图</p>
<p>横坐标：epoch：所有训练数据集都训练过一次 称为一次epoch。</p>
<p>纵坐标：损失 lose</p>
<h3 id="深度学习工具箱"><a href="#深度学习工具箱" class="headerlink" title="深度学习工具箱"></a>深度学习工具箱</h3><h3 id="小样本学习"><a href="#小样本学习" class="headerlink" title="小样本学习"></a>小样本学习</h3><p>计算机视觉中一个目标分类问题，旨在通过一个或者少量样本来学习一个目标类别</p>
<p>数据稀缺、标注代价昂贵：如医学图像的分割，人脸关键点标注。</p>
<p>泛化新样本 分割目标得到关系，创造新样本，创造新概念</p>
<p>现在的机器学习和深度学习都不好解决小样本学习。</p>
<h5 id="名词"><a href="#名词" class="headerlink" title="名词"></a>名词</h5><p>支撑集：S 小样本训练集 （极少量的带标记数据）</p>
<p>查询集：Q 小样本测试集</p>
<p>C-way K-shot：包含C个类别，每个类别是K个标记样本构成。</p>
<p>使用浅层的机器学习模型或者深度学习模型都有过拟合问题。</p>
<p>解决方式：通过辅助集进行学习，再迁移一些知识，帮助新的类别的识别。样本相当于预训练之后再学习小样本</p>
<p>辅助集和小样本任务的支撑集和查询集的类别不相交。不然说明可以找到样本，就不是小样本了。</p>

		</div>

		
		<div class="post-copyright-info w-full my-8 px-2 sm:px-6 md:px-8">
			<div class="article-copyright-info-container">
    <ul>
        <li><strong>Title:</strong> 机器学习概念总结</li>
        <li><strong>Author:</strong> HangYF</li>
        <li><strong>Created at
                :</strong> 2025-02-17 14:25:54</li>
        
            <li>
                <strong>Updated at
                    :</strong> 2025-02-17 14:27:33
            </li>
        
        <li>
            <strong>Link:</strong> https://redefine.ohevan.com/2025/02/17/机器学习概念总结/
        </li>
        <li>
            <strong>
                License:
            </strong>
            

            
                This work is licensed under <a class="license" target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0">CC BY-NC-SA 4.0</a>.
            
        </li>
    </ul>
</div>

		</div>
		

		
		<ul class="post-tags-box text-lg mt-1.5 flex-wrap justify-center flex md:hidden">
			
			<li class="tag-item mx-0.5">
				<a href="/tags/%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93/">#课程总结</a>&nbsp;
			</li>
			
		</ul>
		

		

		
		<div class="article-nav my-8 flex justify-between items-center px-2 sm:px-6 md:px-8">
			
			
			<div class="article-next border-border-color shadow-redefine-flat shadow-shadow-color-2 rounded-medium px-4 py-2 hover:shadow-redefine-flat-hover hover:shadow-shadow-color-2">
				<a class="next" rel="next" href="/2025/02/17/%E5%A4%A7%E4%BA%8C%E4%B8%8B%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E4%B8%8E%E8%AE%A1%E7%AE%97II%E6%9C%9F%E6%9C%AB%E6%80%BB%E7%BB%93/">
					<span class="title flex justify-center items-center">
						<span class="post-nav-title-item">大二下软件工程与计算II期末总结</span>
						<span class="post-nav-item">Next posts</span>
					</span>
					<span class="right arrow-icon flex justify-center items-center">
						<i class="fa-solid fa-chevron-right"></i>
					</span>
				</a>
			</div>
			
		</div>
		


		
	</div>

	
	<div class="toc-content-container">
		<div class="post-toc-wrap">
	<div class="post-toc">
		<div class="toc-title">On this page</div>
		<div class="page-title">机器学习概念总结</div>
		<ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0"><span class="nav-text">机器学习</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%AA%E8%AE%BA"><span class="nav-text">绪论</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A2%84%E6%B5%8B"><span class="nav-text">预测</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8E%A8%E6%96%AD"><span class="nav-text">推断</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E4%BC%B0%E8%AE%A1f"><span class="nav-text">如何估计f</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A2%84%E6%B5%8B%E7%B2%BE%E5%BA%A6%E5%92%8C%E8%A7%A3%E9%87%8A%E6%80%A7%E7%9A%84%E6%9D%83%E8%A1%A1"><span class="nav-text">预测精度和解释性的权衡</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8C%87%E5%AF%BC%E5%AD%A6%E4%B9%A0%E5%92%8C%E6%97%A0%E6%8C%87%E5%AF%BC%E5%AD%A6%E4%B9%A0"><span class="nav-text">指导学习和无指导学习</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BD%92%E7%BA%B3%E5%81%8F%E5%A5%BD-inductive-bias"><span class="nav-text">归纳偏好 inductive bias</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B2%A1%E6%9C%89%E5%85%8D%E8%B4%B9%E7%9A%84%E5%8D%88%E9%A4%90-NO-Free-Lunch"><span class="nav-text">没有免费的午餐 NO Free Lunch</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%9F%E8%AE%A1%E5%AD%A6%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="nav-text">统计学基本概念</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B7%9D%E7%A6%BB"><span class="nav-text">距离</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%87%B8%E5%87%BD%E6%95%B0%EF%BC%8C%E5%87%B9%E5%87%BD%E6%95%B0"><span class="nav-text">凸函数，凹函数</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A8%A1%E5%9E%8B%E8%AF%84%E4%BC%B0%E5%92%8C%E9%80%89%E6%8B%A9"><span class="nav-text">模型评估和选择</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A8%A1%E5%9E%8B-%E5%81%87%E8%AE%BE%E7%A9%BA%E9%97%B4"><span class="nav-text">模型&amp;假设空间</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AD%96%E7%95%A5"><span class="nav-text">策略</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%97%E6%B3%95"><span class="nav-text">算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B3%9B%E5%8C%96%E8%AF%AF%E5%B7%AE-vs-%E7%BB%8F%E9%AA%8C%E8%AF%AF%E5%B7%AE"><span class="nav-text">泛化误差 vs 经验误差</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A8%A1%E5%9E%8B%E9%80%89%E6%8B%A9"><span class="nav-text">模型选择</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AF%84%E4%BC%B0%E6%96%B9%E6%B3%95"><span class="nav-text">评估方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%A7%E8%83%BD%E5%BA%A6%E9%87%8F%EF%BC%9A%E8%A1%A1%E9%87%8F%E6%A8%A1%E5%9E%8B%E6%B3%9B%E5%8C%96%E8%83%BD%E5%8A%9B%E7%9A%84%E8%AF%84%E4%BB%B7%E6%A0%87%E5%87%86%EF%BC%8C%E5%8F%8D%E6%98%A0%E4%BA%86%E4%BB%BB%E5%8A%A1%E9%9C%80%E6%B1%82"><span class="nav-text">性能度量：衡量模型泛化能力的评价标准，反映了任务需求</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%AF%94%E8%BE%83%E6%A3%80%E9%AA%8C"><span class="nav-text">比较检验</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%86%B3%E7%AD%96%E6%A0%91"><span class="nav-text">决策树</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%92%E5%88%86%E5%BA%A6%E9%87%8F"><span class="nav-text">划分度量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%89%AA%E6%9E%9D"><span class="nav-text">剪枝</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9E%E7%BB%AD%E5%80%BC%E5%B1%9E%E6%80%A7%E5%A4%84%E7%90%86"><span class="nav-text">连续值属性处理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BC%BA%E5%A4%B1%E5%80%BC%E5%A4%84%E7%90%86"><span class="nav-text">缺失值处理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8B%93%E5%B1%95-%E8%BD%B4%E5%B9%B3%E8%A1%8C%E5%88%92%E5%88%86"><span class="nav-text">拓展 轴平行划分</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#KNN-k%E8%BF%91%E9%82%BB"><span class="nav-text">KNN k近邻</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B7%9D%E7%A6%BB%E5%BA%A6%E9%87%8F"><span class="nav-text">距离度量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#k%E8%BF%91%E9%82%BB%E5%88%86%E7%B1%BB%E5%99%A8"><span class="nav-text">k近邻分类器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%80%E8%BF%91%E9%82%BB%E5%88%86%E7%B1%BB%E5%99%A8%EF%BC%881-NN%EF%BC%89"><span class="nav-text">最近邻分类器（1-NN）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B3%9B%E5%8C%96%E9%94%99%E8%AF%AF%E7%8E%87"><span class="nav-text">泛化错误率</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#K-%E8%BF%91%E9%82%BB%E5%9B%9E%E5%BD%92"><span class="nav-text">K-近邻回归</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%91%E9%82%BB%E5%B9%B3%E6%BB%91"><span class="nav-text">近邻平滑</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%A8%E8%AE%BA"><span class="nav-text">讨论</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%99%8D%E4%BD%8E%E8%BF%91%E9%82%BB%E8%AE%A1%E7%AE%97"><span class="nav-text">降低近邻计算</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%99%8D%E7%BB%B4"><span class="nav-text">降维</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%91%E4%BC%BC%E6%9C%80%E8%BF%91%E9%82%BB"><span class="nav-text">近似最近邻</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%93%88%E5%B8%8C"><span class="nav-text">哈希</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#SVM-%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA"><span class="nav-text">SVM 支持向量机</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%84%9F%E7%9F%A5%E6%9C%BA"><span class="nav-text">感知机</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E6%80%A7%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA"><span class="nav-text">线性支持向量机</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%B7%9D%E7%A6%BB%E5%BA%A6%E9%87%8F-1"><span class="nav-text">距离度量</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B1%BB%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="nav-text">类的定义</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%81%9A%E7%B1%BB%E5%87%86%E5%88%99"><span class="nav-text">聚类准则</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%9B%B4%E6%8E%A5%E8%AF%95%E6%8E%A2%E6%B3%95%EF%BC%9A%E5%87%AD%E6%84%9F%E8%A7%89%E5%92%8C%E7%BB%8F%E9%AA%8C%E5%AE%9A%E4%B9%89%E4%B8%80%E7%A7%8D%E5%BA%A6%E9%87%8F%E7%9A%84%E5%87%BD%E6%95%B0%EF%BC%88%E4%BA%BA%E4%B8%BA%E5%91%8A%E8%AF%89%E4%B8%80%E4%B8%AA%E8%A7%84%E5%88%99%EF%BC%89"><span class="nav-text">直接试探法：凭感觉和经验定义一种度量的函数（人为告诉一个规则）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B3%BB%E7%BB%9F%E8%81%9A%E7%B1%BB%E6%B3%95"><span class="nav-text">系统聚类法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E8%81%9A%E7%B1%BB%E6%B3%95K-means"><span class="nav-text">动态聚类法K-means</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%81%9A%E7%B1%BB%E8%AF%84%E4%BB%B7"><span class="nav-text">聚类评价</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86"><span class="nav-text">自然语言处理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E4%BA%8E%E8%A7%84%E5%88%99%E7%9A%84%E6%96%B9%E6%B3%95"><span class="nav-text">基于规则的方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E4%BA%8E%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%9A%84%E6%96%B9%E6%B3%95"><span class="nav-text">基于机器学习的方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95"><span class="nav-text">深度学习方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E4%BA%8E%E5%A4%A7%E6%A8%A1%E5%9E%8B%E6%96%B9%E5%BC%8F"><span class="nav-text">基于大模型方式</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%96%87%E6%9C%AC%E8%A7%84%E8%8C%83%E5%8C%96"><span class="nav-text">文本规范化</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AF%8D%E8%AF%AD%E5%88%87%E5%88%86"><span class="nav-text">词语切分</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AF%8D%E8%AF%AD%E8%A7%84%E8%8C%83%E5%8C%96"><span class="nav-text">词语规范化</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA"><span class="nav-text">支持向量机</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%B8%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA"><span class="nav-text">核支持向量机</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C"><span class="nav-text">神经网络</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B1%80%E9%99%90"><span class="nav-text">局限</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%84%9F%E7%9F%A5%E6%9C%BA%E5%AD%A6%E4%B9%A0"><span class="nav-text">感知机学习</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%89%E7%9B%91%E7%9D%A3%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%96%B9%E5%BC%8F"><span class="nav-text">有监督的学习方式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BC%BA%E7%82%B9"><span class="nav-text">缺点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%9A%E5%B1%82%E6%84%9F%E7%9F%A5%E6%9C%BA"><span class="nav-text">多层感知机</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%8D%E5%90%91%E4%BC%A0%E6%92%AD%E7%AE%97%E6%B3%95"><span class="nav-text">反向传播算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C"><span class="nav-text">卷积神经网络</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A8%A1%E5%9E%8B%E8%BD%BB%E9%87%8F%E5%8C%96"><span class="nav-text">模型轻量化</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%89%AA%E6%9E%9D-pruning"><span class="nav-text">剪枝 pruning</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%92%B8%E9%A6%8F"><span class="nav-text">蒸馏</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%87%8F%E5%8C%96"><span class="nav-text">量化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%A4%E5%8F%89%E7%86%B5%E6%8D%9F%E5%A4%B1%E5%87%BD%E6%95%B0"><span class="nav-text">交叉熵损失函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9B%9E%E5%BD%92%E6%8D%9F%E5%A4%B1"><span class="nav-text">回归损失</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E6%8A%80%E5%B7%A7"><span class="nav-text">深度学习技巧</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%B7%A5%E5%85%B7%E7%AE%B1"><span class="nav-text">深度学习工具箱</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B0%8F%E6%A0%B7%E6%9C%AC%E5%AD%A6%E4%B9%A0"><span class="nav-text">小样本学习</span></a></li></ol></li></ol></li></ol>

	</div>
</div>
	</div>
	
</div>
			</div>

			
		</div>

		<div class="main-content-footer">
			<footer class="footer mt-5 py-5 h-auto text-base text-third-text-color relative border-t-2 border-t-border-color">
    <div class="info-container py-3 text-center">
        
        <div class="text-center">
            &copy;
            
              <span>2025</span>
              -
            
            2025&nbsp;&nbsp;<i class="fa-solid fa-heart fa-beat" style="--fa-animation-duration: 0.5s; color: #f54545"></i>&nbsp;&nbsp;<a href="/">HangYF</a>
            
                
                <p class="post-count space-x-0.5">
                    <span>
                        7 posts in total
                    </span>
                    
                        <span>
                            43.6k words in total
                        </span>
                    
                </p>
            
        </div>
        
        <div class="relative text-center lg:absolute lg:left-[20px] lg:top-1/2 lg:-translate-y-1/2 lg:text-left">
            <span class="lg:block text-sm">POWERED BY <?xml version="1.0" encoding="utf-8"?><!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"><svg class="relative top-[2px] inline-block align-baseline" version="1.1" id="圖層_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" width="1rem" height="1rem" viewBox="0 0 512 512" enable-background="new 0 0 512 512" xml:space="preserve"><path fill="#0E83CD" d="M256.4,25.8l-200,115.5L56,371.5l199.6,114.7l200-115.5l0.4-230.2L256.4,25.8z M349,354.6l-18.4,10.7l-18.6-11V275H200v79.6l-18.4,10.7l-18.6-11v-197l18.5-10.6l18.5,10.8V237h112v-79.6l18.5-10.6l18.5,10.8V354.6z"/></svg><a target="_blank" class="text-base" href="https://hexo.io">Hexo</a></span>
            <span class="text-sm lg:block">THEME&nbsp;<a class="text-base" target="_blank" href="https://github.com/EvanNotFound/hexo-theme-redefine">Redefine v2.8.2</a></span>
        </div>
        
        
            <div>
                Blog up for <span class="odometer" id="runtime_days" ></span> days <span class="odometer" id="runtime_hours"></span> hrs <span class="odometer" id="runtime_minutes"></span> Min <span class="odometer" id="runtime_seconds"></span> Sec
            </div>
        
        
            <script data-swup-reload-script>
                try {
                    function odometer_init() {
                    const elements = document.querySelectorAll('.odometer');
                    elements.forEach(el => {
                        new Odometer({
                            el,
                            format: '( ddd).dd',
                            duration: 200
                        });
                    });
                    }
                    odometer_init();
                } catch (error) {}
            </script>
        
        
        
    </div>  
</footer>
		</div>
	</div>

	
	<div class="post-tools">
		<div class="post-tools-container">
	<ul class="article-tools-list">
		<!-- TOC aside toggle -->
		
		<li class="right-bottom-tools page-aside-toggle">
			<i class="fa-regular fa-outdent"></i>
		</li>
		

		<!-- go comment -->
		
	</ul>
</div>
	</div>
	

	<div class="right-side-tools-container">
		<div class="side-tools-container">
	<ul class="hidden-tools-list">
		<li class="right-bottom-tools tool-font-adjust-plus flex justify-center items-center">
			<i class="fa-regular fa-magnifying-glass-plus"></i>
		</li>

		<li class="right-bottom-tools tool-font-adjust-minus flex justify-center items-center">
			<i class="fa-regular fa-magnifying-glass-minus"></i>
		</li>

		<li class="right-bottom-tools tool-dark-light-toggle flex justify-center items-center">
			<i class="fa-regular fa-moon"></i>
		</li>

		<!-- rss -->
		

		

		<li class="right-bottom-tools tool-scroll-to-bottom flex justify-center items-center">
			<i class="fa-regular fa-arrow-down"></i>
		</li>
	</ul>

	<ul class="visible-tools-list">
		<li class="right-bottom-tools toggle-tools-list flex justify-center items-center">
			<i class="fa-regular fa-cog fa-spin"></i>
		</li>
		
		<li class="right-bottom-tools tool-scroll-to-top flex justify-center items-center">
			<i class="arrow-up fas fa-arrow-up"></i>
			<span class="percent"></span>
		</li>
		
		
	</ul>
</div>
	</div>

	<div class="image-viewer-container">
	<img src="">
</div>

	
	<div class="search-pop-overlay">
	<div class="popup search-popup">
		<div class="search-header">
			<span class="search-input-field-pre">
				<i class="fa-solid fa-keyboard"></i>
			</span>
			<div class="search-input-container">
				<input autocomplete="off" autocorrect="off" autocapitalize="off" placeholder="Search..." spellcheck="false" type="search" class="search-input">
			</div>
			<span class="popup-btn-close">
				<i class="fa-solid fa-times"></i>
			</span>
		</div>
		<div id="search-result">
			<div id="no-result">
				<i class="fa-solid fa-spinner fa-spin-pulse fa-5x fa-fw"></i>
			</div>
		</div>
	</div>
</div>
	

</main>



<script src="/js/build/libs/Swup.min.js"></script>

<script src="/js/build/libs/SwupSlideTheme.min.js"></script>

<script src="/js/build/libs/SwupScriptsPlugin.min.js"></script>

<script src="/js/build/libs/SwupProgressPlugin.min.js"></script>

<script src="/js/build/libs/SwupScrollPlugin.min.js"></script>

<script src="/js/build/libs/SwupPreloadPlugin.min.js"></script>

<script>
    const swup = new Swup({
        plugins: [
            new SwupScriptsPlugin({
                optin: true,
            }),
            new SwupProgressPlugin(),
            new SwupScrollPlugin({
                offset: 80,
            }),
            new SwupSlideTheme({
                mainElement: ".main-content-body",
            }),
            new SwupPreloadPlugin(),
        ],
        containers: ["#swup"],
    });
</script>




	
<script src="/js/build/tools/imageViewer.js" type="module"></script>

<script src="/js/build/utils.js" type="module"></script>

<script src="/js/build/main.js" type="module"></script>

<script src="/js/build/layouts/navbarShrink.js" type="module"></script>

<script src="/js/build/tools/scrollTopBottom.js" type="module"></script>

<script src="/js/build/tools/lightDarkSwitch.js" type="module"></script>

<script src="/js/build/layouts/categoryList.js" type="module"></script>



    
<script src="/js/build/tools/localSearch.js" type="module"></script>




    
<script src="/js/build/tools/codeBlock.js" type="module"></script>




    
<script src="/js/build/layouts/lazyload.js" type="module"></script>




    
<script src="/js/build/tools/runtime.js"></script>

    
<script src="/js/build/libs/odometer.min.js"></script>

    
<link rel="stylesheet" href="/assets/odometer-theme-minimal.css">




  
<script src="/js/build/libs/Typed.min.js"></script>

  
<script src="/js/build/plugins/typed.js" type="module"></script>








    
<script src="/js/build/libs/anime.min.js"></script>





    
<script src="/js/build/tools/tocToggle.js" type="module" data-swup-reload-script=""></script>

<script src="/js/build/layouts/toc.js" type="module" data-swup-reload-script=""></script>

<script src="/js/build/plugins/tabs.js" type="module" data-swup-reload-script=""></script>




<script src="/js/build/libs/moment-with-locales.min.js" data-swup-reload-script=""></script>


<script src="/js/build/layouts/essays.js" type="module" data-swup-reload-script=""></script>





	
</body>

</html>